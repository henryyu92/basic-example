 

### 分表

水平分表：以**字段**为依据，按照一定策略（hash、range等），将一个**表**中的数据拆分到多个**表**中

- 每个表的结构都一样
- 每个表的数据都不一样，没有交集
- 所有表的幷集是全量数据

垂直分表：以**表**为依据，按照业务归属不同，将不同的字段拆分到不同的表中

- 每个表的数据结构不同
- 表中的数据也不同，并且没有交集
- 所有表的幷集是全量数据



水平分表影响：

- join 操作变得困难
- 外键约束受影响

垂直分表影响：

- 不能保证事务

### 分布式全局唯一 ID

分表之后，数据分布在不同的表中，如果使用数据库的自增 ID 策略会出现重复 ID 的问题，因此需要自定义生成 ID。

#### `Snowflake`

`snowflake`  算法生成的 id 由 64 位的整数表示，其组成结构为：

```
0 0000...0000 00...00 000...000

1 bit 的符号位，为 0
41 bit 的时间位，表示当前机器时间和初始时间的毫秒差值
10 bit 的机器 id，可以通过多台机器生成 id，因此只能保证生成的 id 趋势递增而不保证严格递增
12 bit 的自增 id，也就是每个机器可以在 1ms 内生成 4096 个 id
```

`snowflake` 算法存在的问题：

- 时钟回拨，导致时间位有可能相同从而导致生成重复的 id

时钟回拨问题解决方案：

- 机器启动时检查上次的时间，如果有较大回拨则启动失败；第一次启动时将其他机器时间和当前机器系统时间对比，如果时差较大则启动失败，定时记录当前机器时间
- 关闭 NTP 时间同步，如果发生时钟回拨需要等待重试使得时间能够恢复，如果时间回拨较大或者多次重试后仍未能追上则应该返回错误并且报警，将该机器节点下线

### 数据分片

分表时将数据通过分片策略划分为不同的区域，每个区域负责对应的数据，常用的数据分片策略：

- range 分片：根据某个 key 或者多个 key 的范围将数据划分到多个不同的区域
- hash 分片：事先指定分区的数量，然后通过对数据进行 hash 操作后取模计算对应的分区

### Sharding jdbc



https://shardingsphere.apache.org/index_zh.html
**建表规范**

规范2： 表命名总长度不能超过26位

规范3： 表名由英文单词与下划线组成，表名中禁止使用中横线‘-’，推荐(业务前缀_功能统称_功能点)， eg: bs_user, bp_project_status_log

规范4： 单词之间用下划线隔开，严禁使用中文拼音缩写（鉴于英语水平可用全拼（不推荐））。对于单词超长的，可使用单词缩写，但是单词缩写必须能够完整表达原单词的含义。

规范5： 表名必须使用小写，如果大小写混合用，可能存在abc,Abc,ABC等多个表共存，容易导致混乱；

规范6： 无特殊用途，线上使用InnoDB存储引擎，innodb主键推荐使用自增列；

`存储精确浮点数必须使用DECIMAL替代FLOAT和DOUBLE，浮点数存在误差；

所有表都默认加两列：

1:createtm timestamp not null default current_timestamp

2:updatetm timestamp default current_timestamp on update current_timestamp

Remark和status看数据表复杂度添加

1. `remark` varchar(200) DEFAULT NULL COMMENT '备注',
2. `status` int(10) DEFAULT '0' COMMENT '状态 0 保存  1已付 2付款中 -1作废 -2 退款',
3. 相同用途的字段，在各个表里的定义属性完全一致；`

**数值类型** 2.TEXT系列

仅当需存储的字节数可能超过20000时，使用TEXT系列类型（TEXT、MEDIUMTEXT、LONGTEXT）。并和原表进行分拆，与原表主键组成新表存储，且每个表只允许有一个TEXT系列类型字段。

**2.1.2表** 规范7： 表字符集选择utf8， 排序规则为utf8_general_ci

规范8： 每个表都需要添加表注释，方便其他开发人员查看

规范9： 合理分表，控制单表数据量，int型建议不超过1000w，含char则不超过500w

规范10： 临时表命名方式：temp_表缩写，备份表一律以 原表明_bak+日期为准

规范11： 字段名必须非Mysql关键字具体的可以查看MySQL关键字 文档(详见附录)

规范12： 控制单表列数量，字段少而精，字段数建议在20以内；

规范13： 字段名长度不得超过30位；

规范14： 存储精确浮点数必须使用DECIMAL替代FLOAT和DOUBLE，浮点数存在误差；

规范15： 整形定义中不显示规定显示长度，比如使用INT，而不是INT(4)；

规范16： 尽可能不使用TEXT、BLOB类型，varchar的性能会比text高很多；实在避免不了blob，请拆表，单独存放blob字段数据；

规范17： 只存储年使用YEAR类型；

规范18： 如果是索引字段，强烈建议定义为not null；

规范20： Mysql字段上禁止单独指定字符集；

规范21： 表的每个字段都需要添加相应注释，方便其他开发人员查看；

规范22： 字段的命名需要有含义；

**2.1.4 约束的命名** 约定:  约束名的最大长度为30位

规范23： 主键约束：pk_表名_字段名

规范24： 尽量少的使用外键，请由程序保证约束；

规范25： 唯一性约束：uniq_表名缩写_字段名

**2.1.5 索引的命名**

约定: 索引名的最大长度为30位

规范26： 索引：idx_表名_字段名

规范27： 索引中的字段数建议不超过5个，唯一键由3个以下字段组成，唯一键不和主键重复

规范28： 索引字段的顺序需要考虑字段值去重之后的个数，个数多的放在前面

规范29： 索引名称必须使用小写

规范30： UPDATE、DELETE语句也需要根据WHERE条件添加索引

规范31： 不建议使用%前缀模糊查询，例如LIKE “%koo”，这样会导致无法使用列上的索引而做全表扫描

规范32： 合理创建联合索引（避免冗余），(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c)

规范33： 单张表的索引数量控制在5个以内，禁止在每一个where条件列上创建索引，索引一定不是越多越好(能不加就不加，要加的一定得加)，去重后记录条数过少不适合建索引，例如“性别”，“状态status”；

**DML**

**2.1 SQL规范** 规范1： SELECT语句必须指定具体字段名称，禁止写成*。因为SELECT *会将不该读的数据也从MySQL里读出来，造成网卡压力。且表字段一旦更新，但model层没有来得及更新的话，系统会报错。

规范2： insert语句指定具体字段名称，不要写成insert into t1 values(…)，道理同 规范1。

规范3： insert into…values(XX),(XX),(XX)…。这里(XX)的值不要超过5000个。值过多会引起主从同步延迟。

规范4： SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内。因为UNION ALL不需要去重，节省数据库资源，提高性能。

规范5： in值列表限制在500以内。例如select… where user_id in(….500个以内…)，这么做是为了减少底层扫描，减轻数据库压力从而加速查询。

规范6： 除静态表或小表（100行以内），DML语句必须有where条件，且使用索引查找。

规范7： WHERE条件里等号左右字段类型必须一致，否则无法利用索引。

规范8： SELECT|UPDATE|DELETE|REPLACE要有WHERE子句，且WHERE子句的条件必需使用索引查找。

规范9： WHERE子句中禁止只使用全模糊的LIKE条件进行查找，必须有其他等值或范围查询条件，否则无法利用索引。

规范10： 索引列不要使用函数或表达式，否则无法利用索引。如where length(name)='Admin'或where user_id+2=10023。

规范11： 减少使用or语句，可将or语句优化为union，然后在各个where条件上建立索引。如where a=1 or b=2优化为where a=1… union …where b=2, key(a),key(b)。

**2.2 多表连接**

规范12： 禁止跨db的join语句。因为这样可以减少模块间耦合，为数据库拆分奠定坚实基础。

规范13： 禁止在业务的更新类SQL语句中使用join，比如update t1 join t2…。

规范14： 不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用join来代替子查询。

规范15： 多表join最好不要超过3个表。

规范16： 多表连接查询推荐使用别名，且SELECT列表中要用别名引用字段，数据库.表格式，如select a from db1.table1 alias1 where …。

规范17： 在多表join中，尽量选取结果集较小的表作为驱动表，来join其他表。

**2.3 事务**

规范18： 事务中INSERT|UPDATE|DELETE|REPLACE语句操作的行数控制在2000以内，以及WHERE子句中IN列表的传参个数控制在500以内。

规范19： 对于有auto_increment属性字段的表的插入操作，并发需要控制在200以内。

规范20： 程序设计必须考虑“数据库事务隔离级别”带来的影响，包括脏读、不可重复读和幻读。建议事务隔离级别为repeatable-read。

规范21： 事务里包含SQL不超过5个（支付业务除外）。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等雪崩问题。

规范22： 事务里更新语句尽量基于主键或unique key，如update … where id=XX; 否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。

规范23： 尽量把一些典型外部调用移出事务，如调用webservice，访问文件存储等，从而避免事务过长。

**2.4 排序和分组**

规范24： order by、group by、distinct这些SQL尽量利用索引直接检索出排序好的数据。。

规范25： 包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。

规范26： 禁用update|delete t1 … where a=XX limit XX; 这种带limit的更新语句。因为会导致主从不一致，导致数据错乱。建议加上order by PK。

规范27： 禁止使用关联子查询，如update t1 set … where name in(select name from user where…);效率极其低下。

规范28： 禁用procedure、function、trigger、views、event、外键约束。因为他们消耗数据库资源，降低数据库实例可扩展性。推荐都在程序端实现。

规范29： 禁止联表更新语句，如update t1,t2 where t1.id=t2.id…。
## 事务
事务是一组原子性的 SQL 查询，如果其中任意一个语句因为崩溃或其他原因无法执行，也就是说事务内的语句，要么全部执行成功，要么全部执行失败。MySQL 中只有 InnoDB 存储引擎支持事务。

事务具有 ACID 特性：
- ```原子性(Automicity)```：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作
- ```一致性(Consistency)```：数据库总是从一个一致性的状态到另外一个一致性状态
- ```隔离性(Isolation)```：一个事务在最终提交之前，对其他事务是不可见的，隔离性受隔离级别影响
- ```持久性(Durability)```：一旦事务提交，则其所做的修改就会永久保存到数据库中，此时即使数据库崩溃，修改的数据也不会丢失

### 隔离级别
- ```读未提交(Read Uncommitted)```：在 Read Uncommitted 级别，事务中的修改即使没有提交，其他事务也是可见的。事务可以读取未提交的数据的情况被称为脏读(Dirty Read)
- ```读已提交(Read Committed)```：在 Read Committed 级别，一个事务开始直到提交之前所做的任何修改对其他事务来说是不可见的。这个级别解决了脏读的问题，但是在事务提交前后相同的查询会读到不同的数据，这种情况称为不可重复读(noRepeatable read)。
- ```可重复读(Repeatable Read)```：在 Repeatable Read 级别中，同一事务中多次读取同样的记录结果是一致的。这个级别解决了不可重复读的问题，但是当某个事务在读取某个范围内的纪录时，另外一个事务又在该范围内插入了新的记录，于是该事务再次读取这个范围时就会产生幻行(Phantom Row)，这种现象称为幻读(Phantom Read)。
- ```串行化(Serializable)```：Serializable 是最高的隔离级别，它通过强制事务串行执行，避免了幻读的产生。该级别会在读取每一行数据上都家所，所以可能导致大量的超时和锁争用的问题。

### 多版本并发控制(MVCC)

Innodb 存储引擎引入了 MVCC 机制保证一致性读(快照读)，也就是说为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值而不用等待事务执行完毕释放锁。

**MVCC 只在 Repeatable read 和 Read Commit 两个事务隔离级别下工作**。

InnoDB 存储引擎会在每行记录后添加几个隐藏的列来记录信息：

- `DATA_TRX_ID`：记录该行的事务版本号，每次开启事务时会递增
- `DATA_ROLL_PTR`：记录该行的 undo 日志指针，用于查找修改之前的数据，数据每次被修改会记录旧的数据到 undo 日志中，从而形成一个版本链
- `DELETE BIT`：记录该行删除时的事务版本号

在 MVCC 中数据的增删改查不是直接执行的，还需要处理记录的版本号：

- `SELECT`：InnoDB 在查询时会检查每行记录的版本链，只有满足条件的数据才能返回
  - 数据行的 `DATA_TRX_ID` 必须小于等于当前的事务版本，保证数据是在当前事务之前保存的
  - 数据行的 `DELETE BIT` 未定义或者大于当前的事务版本，保证数据在当前事务之前未删除或者是在当前事务之后删除
- `DELETE`：记录当前事务版本到 `DELETE BIT`，若事务会滚则去除 `DELETE BIT`，若事务提交则删除行
- `INSERT`：创建行记录，并将当前事务版本作为 `DATA_TRX_ID`，如果需要会滚则丢弃 undo log
- `UPDATE`：复制需要更新的记录到 undo log 并将记录的 `DELETE BIT` 设置未当前事务版本，然后修改数据后将当前事务版本作为 `DATA_TRX_ID`，并将新记录的 ``DATA_ROLL_PTR` 指向 undo log 中旧的数据

MVCC 将读操作分为快照读 (snapshot read) 和当前读(current read)，快照读指的是简单的不加锁的读操作，当前读则包括加锁的读操作以及插入、更新、删除操作。

在快照读的情况下，事务在第一次读的时候生成 readView，后续读操作都是读同一个快照，因此不会出现幻读问题。

```
+----------------------------------+------------------------------------+
| Tx_1                             |    TX_2                            |
+----------------------------------+------------------------------------+
|                                  |        begin                       |
+----------------------------------+------------------------------------+
| 		begin;		               |                                    |
+----------------------------------+------------------------------------+
|      select * from t;            |                                    |
+----------------------------------+------------------------------------+
|                                  | insert into t(id, x) values(2, 2); |
+----------------------------------+------------------------------------+
| select * from t;                 |                                    |
+----------------------------------+------------------------------------+
```

对于当前读的情况，每次读取的都是最新的数据，MVCC 不能保证不出现幻读，在当前事务中更新了其他事务插入的数据会导致数据更新成功从而使得再次读的时候可以读到其他版本的数据，此时需要通过 Next-Key 锁保证不出现幻读的情况。

```
+----------------------------------+------------------------------------+
| Tx_1                             |    TX_2                            |
+----------------------------------+------------------------------------+
| begin;                           |    begin;                          |
+----------------------------------+------------------------------------+
| select * from t;				   |	                                |
+----------------------------------+------------------------------------+
|                                  | insert into t(id, x) values(2, 2); |
+----------------------------------+------------------------------------+
| update t set x = 1 where id = 2; |                                    |
+----------------------------------+------------------------------------+
| select * from t;                 |                                    |
+----------------------------------+------------------------------------+
```

### 事务日志

InnoDB 事务日志包括 `redo log` 和 `undo log` 。`undo log` 用于保证事务的一致性，`redo log` 保证事务的原子性和持久性。

#### Redo Log

`redo log` 是物理日志，记录的是数据页的物理修改，用于恢复提交后的物理数据页，也就是恢复到最后一次提交的状态。

`redo log` 包含两部分：内存中的日志缓冲 (`redo log buffer`) 和磁盘上的日志文件 (`redo log file`)。

Redo Log 的写入流程：

- 事务在执行时需要先加载磁盘上的数据到内存中，并修改内存中的数据拷贝
- 生成 Redo Log 并写入 redo log buffer，记录的是修改后的值
- 事务 commit 时将 redo log buffer 中的数据以追加写的方式刷新到 redo log file 中
- 定期将内存中修改的数据刷新到磁盘中

InnoDB 通过 `force log at commit` 机制实现事务的持久性，也就是说在事务提交的时候必须要将日志缓冲中的日志刷盘到日志文件中才会完成 commit。

#### Undo Log

`undo log` 是逻辑日志，根据每行记录进行记录，用于回滚行记录到某个特定版本。

数据在事务中修改的时候还会记录 `undo log`，其中记录的是修改之前的数据，在进行回滚时会读取到相应的数据进行回滚。在 MVCC 中通过版本号实现非锁定的一致性读。

当事务提交时，InnoDB 不会立即删除 `undo log`，而是将事务对应的 `undo log` 放到删除列表中，由 purge 来删除。
## 事务

事务是一组执行动作组成的工作单元，该工作单元中的所有操作要么全部成功，要么全部失败。事务具有 ACID 四个特性：

- 原子性(`Automicity`)：事务中的所有操作作为不可分割的最小单元，要么执行成功，要么执行失败，不会出现部分成功
- 一致性(`Consistency`)：事务在执行前后都处于有效的状态，也就是在事务执行前后都满足数据库的约束条件
- 隔离性(`Isolation`)：事务在最终提交前对数据的修改对其他事务不可见，事务的隔离性受隔离级别影响
- 持久性(`Durability`)：事务提交之后数据会持久化，即使数据库崩溃也不会丢失

事务在并发执行时会并发的修改数据，此时事务中的读操作就会出现异常的情况：

- 脏读：事务中的读操作读取到了其他事务未提交的数据
- 不可重复读：事务中相同的读操作在不同时刻读取到的数据不相同
- 幻读：事务中对数据修改之后再次读取会看到其他事务新增但是当前事务并未修改的数据

数据库提供了事务的隔离级别用于解决事务在并发执行时的数据问题，不同的存储引擎可以实现不同的隔离级别：

- 读未提交(`Read Uncommitted`)：事务中可以看到其他事务还未提交的数据，会发生脏读
- 读已提交(`Read Committed`)：事务中可以他看其他已经提交事务修改的数据，可以避免脏读，但是不能避免不可重复读
- 可重复读(`Repeatable Read`)：

### 隔离级别
- ```读未提交(Read Uncommitted)```：在 Read Uncommitted 级别，事务中的修改即使没有提交，其他事务也是可见的。事务可以读取未提交的数据的情况被称为脏读(Dirty Read)
- ```读已提交(Read Committed)```：在 Read Committed 级别，一个事务开始直到提交之前所做的任何修改对其他事务来说是不可见的。这个级别解决了脏读的问题，但是在事务提交前后相同的查询会读到不同的数据，这种情况称为不可重复读(noRepeatable read)。
- ```可重复读(Repeatable Read)```：在 Repeatable Read 级别中，同一事务中多次读取同样的记录结果是一致的。这个级别解决了不可重复读的问题，但是当某个事务在读取某个范围内的纪录时，另外一个事务又在该范围内插入了新的记录，于是该事务再次读取这个范围时就会产生幻行(Phantom Row)，这种现象称为幻读(Phantom Read)。
- ```串行化(Serializable)```：Serializable 是最高的隔离级别，它通过强制事务串行执行，避免了幻读的产生。该级别会在读取每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。

### 快照读和当前读

### 多版本并发控制

Innodb 存储引擎通过引入 MVCC 机制保证事务不会看到异常的数据，**MVCC 可以在 Read Committed 和 Repeatable Read 两个事务隔离级别有效**。在多事务同时存在时，MVCC 通过版本链和 ReadView 一致性视图来实现不同事务读到不同的数据。

#### 版本链

InnoDB 存储引擎会在每行记录后添加几个隐藏的列来记录信息：

- `DATA_TRX_ID`：记录该行的事务版本号，每次开启事务时会递增
- `DATA_ROLL_PTR`：记录该行的 undo 日志指针，用于查找修改之前的数据，数据每次被修改会记录旧的数据到 undo 日志中，从而形成一个版本链
- `DELETE BIT`：记录该行删除时的事务版本号

事务版本号并不是一开启事务就会生成，而是在对表中的记录做修改 (`update, insert, delete`) 时才会分配，否则只有默认的 0。 

在 MVCC 中数据的增删改查不是直接执行的，还需要处理记录的版本号：

- `SELECT`：InnoDB 在查询时会检查每行记录的版本链，只有满足条件的数据才能返回
  - 数据行的 `DATA_TRX_ID` 必须小于等于当前的事务版本，保证数据是在当前事务之前保存的
  - 数据行的 `DELETE BIT` 未定义或者大于当前的事务版本，保证数据在当前事务之前未删除或者是在当前事务之后删除
- `DELETE`：记录当前事务版本到 `DELETE BIT`，若事务会滚则去除 `DELETE BIT`，若事务提交则删除行
- `INSERT`：创建行记录，并将当前事务版本作为 `DATA_TRX_ID`，如果需要回滚则丢弃 undo log
- `UPDATE`：复制需要更新的记录到 undo log 并将记录的 `DELETE BIT` 设置未当前事务版本，然后修改数据后将当前事务版本作为 `DATA_TRX_ID`，并将新记录的 ``DATA_ROLL_PTR` 指向 undo log 中旧的数据

#### ReadView

ReadView 用于判断当前版本链中哪个版本的数据对事务是可见的，ReadView 包含 4 个重要的内容：

- `m_ids`：生成 ReadView 时当前系统中活跃的读写事务的 id 列表
- `min_trx_id`：生成 ReadView 时当前系统活跃读写事务中最小的事务 id，也就是 `m_ids` 的最小值
- `max_trx_id`：生成 ReadView 时系统中应该分配给下一个事务的 id
- `creator_trx_id`：生成 ReadView 的事务 id

通过 ReadView就可以控制在访问某条记录时版本链中数据的可见性：

- 如果被访问版本的 `DATA_TRX_ID` 属性值与 ReadView 中的 `creator_trx_id` 相同，则说明该版本的数据是当前事务修改的，因此该版本数据对当前事务可见
- 如果被访问版本的 `DATA_TRX_ID` 属性值小于 ReadView 中的 `min_trx_id`，则说明该版本的数据是在生成 ReadView 之前已经提交，因此该版本可以被当前事务访问
- 如果被访问版本的 `DATA_TRX_ID` 属性值大于 ReadView 中的 `max_trx_id`，则说明生成该版本的数据的事务是在生成 ReadView 之后才开启，因此该版本数据对当前事务不可见
- 如果被访问版本的 `DATA_TRX_ID` 属性值在 ReadView 的 `min_trx_id` 和 `max_trx_id` 之间，则需要判断 `DAT_TRX_ID` 属性值是否在 `m_ids` 列表中，如果在则说明创建 ReadView 时生成该版本的事务还是活跃的，则该版本的数据是不可见的，如果不在则说明创建 ReadView 时生成该版本的事务已经提交，则该版本的数据是可见的

如果某个版本的数据对当前事务不可见的话，就会沿着版本链查找记录的下一个版本并判断该版本的可见性，直到最后一个版本，如果都不可见的话就不包含该记录。

`READ COMMITTED` 和 `REPEATABLE READ` 这两个隔离级别产生的 ReadView 时机不同，因而对数据的可见性也是不同的，一旦生成 ReadVew，其内部的属性就不会发生变化。

- `READ COMMITTED` 隔离级别在每次读取数据时生成 ReadView，因此在此隔离级别下会出现不可重复读的问题
- `REPEATABLE READ` 隔离级别在第一此读取数据时生成 ReadView

|      |               tx_1               |                tx_2                |       tx_3       |
| :--: | :------------------------------: | :--------------------------------: | :--------------: |
|  1   |              begin;              |               begin;               |      begin;      |
|  2   |         select * from t;         |                                    |                  |
|  3   |                                  | insert into t(id, x) values(2, 2); |                  |
|  4   |                                  |              commit;               |                  |
|  5   |                                  |                                    | select * from t; |
|  6   | update t set x = 3 where id = 2; |                                    |                  |
|  7   |                                  |                                    | select * from t; |
|  8   |             commit;              |                                    |                  |
|  9   |                                  |                                    | select * from t; |

- 1 时刻开启两个事务
- 2 时刻 tx_1 查询数据，此时整个

#### 当前读

通过 ReadView 读取的数据称为快照读，快照读在第一次读的时候生成 ReadView，后续的所有读操作都使用同一个 ReadView，因此能够保证数据可重复读。

对于会修改数据的操作(`update, insert, delete`) 则需要读取到最新的数据，因此称为当前读。当前读会修改已经提交的的数据，并且当前读之后会重新生成 ReadView，这样就会导致在当前读前后两次读取的数据不一致，从而出现幻读。

```
+----------------------------------+------------------------------------+
| Tx_1                             |    TX_2                            |
+----------------------------------+------------------------------------+
| begin;                           |    begin;                          |
+----------------------------------+------------------------------------+
| select * from t;				   |	                                |
+----------------------------------+------------------------------------+
|                                  | insert into t(id, x) values(2, 2); |
+----------------------------------+------------------------------------+
| update t set x = 1 where id = 2; |                                    |
+----------------------------------+------------------------------------+
| select * from t;                 |                                    |
+----------------------------------+------------------------------------+
```

### 事务日志

InnoDB 事务日志包括 `redo log` 和 `undo log` 。`undo log` 用于保证事务的一致性，`redo log` 保证事务的原子性和持久性。

#### Redo Log

`redo log` 是物理日志，记录的是数据页的物理修改，用于恢复提交后的物理数据页，也就是恢复到最后一次提交的状态。

`redo log` 包含两部分：内存中的日志缓冲 (`redo log buffer`) 和磁盘上的日志文件 (`redo log file`)。

Redo Log 的写入流程：

- 事务在执行时需要先加载磁盘上的数据到内存中，并修改内存中的数据拷贝
- 生成 Redo Log 并写入 redo log buffer，记录的是修改后的值
- 事务 commit 时将 redo log buffer 中的数据以追加写的方式刷新到 redo log file 中
- 定期将内存中修改的数据刷新到磁盘中

InnoDB 通过 `force log at commit` 机制实现事务的持久性，也就是说在事务提交的时候必须要将日志缓冲中的日志刷盘到日志文件中才会完成 commit。

#### Undo Log

`undo log` 是逻辑日志，根据每行记录进行记录，用于回滚行记录到某个特定版本。

数据在事务中修改的时候还会记录 `undo log`，其中记录的是修改之前的数据，在进行回滚时会读取到相应的数据进行回滚。在 MVCC 中通过版本号实现非锁定的一致性读。

当事务提交时，InnoDB 不会立即删除 `undo log`，而是将事务对应的 `undo log` 放到删除列表中，由 purge 来删除。





http://mysql.taobao.org/monthly/2017/12/01/
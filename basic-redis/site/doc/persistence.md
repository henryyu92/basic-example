## Redis 持久化
Redis 提供了不同的持久化配置：
- RDB 持久化方式以指定时间间隔执行数据集的时间点快照
- AOF 持久化方式记录服务器接收的每个写入操作，在服务器重启时以重放的方式重建原始数据集。使用与 Reids 协议本身相同的格式以追加的方式记录命令，当 Redis 过大时可以以后台进程重建。
- Redis 也可以完全不使用持久化
- Redis 也支持同时使用 AOF 和 RDB 持久化，但是在这种情况下，当 Redis 重启时，AOF 将用于数据的重建，因为它能保证数据是完整的
### RDB 持久化
Redis 提供了 RDB 持久化功能，可以将 Redis 的内存中的数据库状态保存到磁盘避免数据意外丢失。RDB 持久化操作可以手动执行，也可以根据服务器配置选项定期执行，RDB 持久化将某个时间点上的数据库状态保存到一个 RDB 文件。
#### RDB 优势和劣势
RDB 是某个时间点上的数据库状态的数据快照，有如下优势：
- RDB 是一个非常紧凑的二进制文件，表示某一时刻 Redis 数据集的快照，RDB 文件非常适合用于备份
- RDB 非常适合灾备，可以将单个压缩文件传输到远端数据中心进行灾备
- RDB 不会影响 Redis 性能，因为 Redis 父进程仅仅是 fork 了一个子进程，而其他所有的持久化操作都是子进程完成的，父进程永远不会执行磁盘 IO
- 在数据量比较大的情况下，相较于 AOF，RDB 能更快的重启

RDB 也存在一些劣势：
- 如果需要在 Redis 停止工作时将数据丢失的可能性降到最低，RDB 并不是很好的选择，因为一般 RDB 的时间间隔比较久，这段时间内的数据变更将会丢失
- RDB 需要 fork 子进程才能将数据持久化到磁盘，当数据量很大时 fork 可能会非常耗时，并且如果 CPU 性能不佳可能会导致 Redis 停止服务几毫秒甚至一秒

#### 创建 RDB 文件
Redis 提供了 SAVE 和 BGSAVE 两个命令用于生成 RDB 文件。SAVE 命令会阻塞 Redis 服务器进程直到 RDB 文件创建完毕为止，在服务器进程阻塞期间不能处理任务命令请求；BGSAVE 命令会派生出一个子进程，然后由子进程负责创建 RDB 文件，子进程将数据集写入到一个临时的 RDB 文件中，当子进程写入完成之后该文件就替代旧的 RDB 文件，服务器进程(父进程)继续处理命令请求。

Redis 没有提供 RDB 载入命令，而是在 Redis 服务器启动时检测是否存在 RDB 文件，如果检测到存在 RDB 文件则自动加载 RDB 文件。如果服务器开启了 AOF 持久化功能，那么服务器会优先使用 AOF 文件来还原数据库状态。在载入 RDB 文件期间，服务器会一直处于阻塞状态直到载入工作完成为止。
#### RDB 配置
Redis 可以通过设置服务器的 save 选项让服务器每隔一段时间自动执行 BGSAVE 命令。默认情况下，Redis 将数据集快照存放在磁盘上名为 dump.rdb 的二进制文件中。可以在配置文件中设置数据集在 N 秒内有 M 个更改则 dump 一次数据集的快照：
```conf
dbfilename dump.rdb
save 900 1
save 300 10
save 60 10000
```
配置中只需要满足三个条件中的一个就会执行 BGSAVE 命令：
- 服务器在 900s 内对数据库进行了至少 1 次修改
- 服务器在 300s 内对数据库进行了至少 10 次修改
- 服务器在 60s 内对数据库进行了至少 10000 次修改
#### RDB 文件结构
一个完整的 RDB 文件包含几个部分：

REDIS|db_version|database|EOF|check_sum
-|-|-|-|-

- ```REDIS```：这个部分长度为 5 个字节，保存着 "REDIS" 五个字符，通过这五个字符 Redis 在载入文件时可以检查该文件是否是 RDB 文件
- ```db_version```：长度为 4 字节，值是一个字符串表示的整数，记录了 RDB 文件的版本号
- ```database```：包含着零个或任意多个数据库，以及各个数据库中的键值对数据。如果服务器的数据库状态为空，那么这部分长度为 0；如果服务器的数据库状态为非空，那么根据数据库所保存的键值对的数量、类型和内容的不同，这部分的长度会有所不同
- ```EOF```：长度为 1 字节，标识 RDB 文件正文内容结束，当载入程序遇到这个值得时候表示所有的键值对已经载入完毕
- ```check_sum```：8 字节无符号整数，保存前 4 个部分的内容的校验和。服务器在载入 RDB 文件时，会将载入数据所计算出的校验和与 check_sum 所记录的校验和进行对比，以此来检查 RDB 文件是否出错或者损坏

每个非空的 database 部分在 RDB 文件中都可以保存为 SELECTDB、db_number、key_value_pairs 三个部分：

SELECTDB|db_number|key_value_pairs
-|-|-

- ```SELECTDB```：长度为 1 个字节，当载入程序遇到这个值的时候，意味着接下来读入的是一个数据库号码
- ```db_number```：保存一个数据库号码，当载入程序读入 db_number 部分之后会调用 SELECT 命令根据读入的数据库号进行数据库切换，使得之后读入的键值对可以载入到正确地数据库中
- ```key_value_pairs```：保存了数据库中所有的键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起

不带过期时间的键值对在 RDB 文件中由 TYPE、key、value 三部分组成，带有过期时间的键值对会增加 EXPIRETIME_MS、ms 两部分：

EXPIRETIME_MS|ms|TYPE|key|value
-|-|-|-|-

- ```EXPIRETIME_MS```：长度为 1 字节，告知载入程序接下来要读取的是一个以毫秒为单位的过期时间，如果键值对没有过期时间则没有该部分
- ```ms```：一个 8 字节长的带符号整数，记录着一个以毫秒为单位的 UNIX 时间戳，这个时间戳就是键值对的过期时间，如果键值对没有过期时间则没有该部分
- ```TYPE```：记录了 value 的类型，长度为 1 字节，代表了一种对象类型或底层编码。服务器读入 RDB 文件中的键值对数据时会根据 TYPE 的值来决定如何读入和解析 value 的数据
  - REDIS_RDB_TYPE_STRING：字符串对象
  - REDIS_RDB_TYPE_LIST：列表对象
  - REDIS_RDB_TYPE_SET：集合对象
  - REDIS_RDB_TYPE_ZSET：有序集合对象
  - REDIS_RDB_TYPE_HASH：哈希表对象
  - REDIS_RDB_TYPE_SET_INTSET：整数集合对象
  - REDIS_RDB_TYPE_LIST_ZIPLIST：压缩列表对象
  - REDIS_RDB_TYPE_ZSET_ZIPLIST
  - REDIS_RDB_TYPE_HASH_ZIPLIST
- ```key```：一个字符串对象，随内容长度变化
- ```value```：根据 TYPE 的不同保存的内容结构和长度不同

RDB 文件中的每个 value 部分都保存了一个值对象，每个值对象的类型都由与之对应的 TYPE 记录。
- 字符串对象
- 列表对象
- 集合对象
- 哈希表对象
- 有序集合对象
- 整数集合对象
- 压缩列表对象

### AOF 持久化
除了 RDB 持久化之外，Redis 还提供了 AOF(Append Only File)持久化功能，与 RDB 持久化通过保存数据库中的键值对来记录数据库状态不同，AOF 持久化时通过保存 Redis 服务器所执行的命令来记录数据库状态的。

#### AOF 优势和劣势
AOF 的优势：
- AOF 持久化能保证更少的数据丢失，AOF 支持多种 fsync 策略：不使用 fsync；每秒 fsync；每次查询都 fsync；即使使用 Redis 默认的策略，即每秒 fsync，Redis 性能仍然很好，因为使用后台线程执行 fsync
- AOF 是一个追加日志，因此掉电也不会有搜索或者损坏问题，即使由于某些原因(磁盘已满)日志以半写命令结束，redis-check-aof 工具也能够轻松修复
- 当 AOF 太大时，Redis 会自动在后台重写 AOF；重写是完全安全的，因为当Redis继续附加到旧文件时，使用创建当前数据集所需的最小操作集生成一个全新的文件，并且一旦第二个文件准备就绪，Redis会切换两个并开始附加到新的那一个
- AOF 以易于理解和解析的格式将所有操作记录在日志中，AOF 日志可以轻松的导出用于恢复数据集


AOF 的劣势：
- AOF 文件通常比同一数据集的 RDB 文件大
- AOF 在某些 fsync 策略下可能会比 RDB 慢，一般来说即使设置每秒 fsync 性能也是非常高的

#### AOF 持久化实现
AOF 持久化功能的实现可以分为命令追加(append)、文件写入、文件同步三个步骤。

当 AOF 持久化功能处于打开状态时，服务器会在执行完一个写命令之后以协议格式将被执行的写命令追加到服务器状态的 aof_buf 缓冲区的末尾。

Redis 服务进程是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求以及向客户端发送命令回复，时间事件负责执行定时运行的函数。服务器每次结束一个事件循环之前都会调用 flushAppendOnlyFile 函数考虑是否需要将 aof_buf 缓冲区中的内容写入和保存到 AOF 文件里面，flushAppendOnlyFile 函数的行为由服务器配置的 appendfsync 选项值来决定。

#### AOF 文件载入和数据还原
因为 AOF 文件包含了重建数据库状态所需的所有命令，因此服务器只需要服务并重新执行一遍 AOF 文件中保存的所有命令就可以还原服务器关闭之前的数据库状态。

Redis 读取 AOF 文件并还原数据库状态的详细步骤：
- 创建一个不带网络连接的伪客户端。因为 Redis 的命令只能在客户端上下文中执行，而载入 AOF 文件时所使用的命令直接来源于 AOF 文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行 AOF 文件保存写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一致
- 从 AOF 文件中分析并读取一条写命令
- 使用伪客户端执行被读出的写命令
- 重复执行读取写命令和执行写命令直到 AOF 文件中的所有写命令都被处理完为止
#### AOF 重写
随着写操作的执行，AOF 文件将会越来越大，Redis 支持在后台重建 AOF 而不会中断对客户端的服务。通过这个功能 Redis 可以创建一个新的 AOF 文件来替换现有的 AOF 文件，两个 AOF 文件保存的数据库状态相同但新的 AOF 文件不会包含任何浪费空间的冗余命令。

AOF 文件重写并不需要对现有的 AOF 文件进行任何读取、分析或写入操作，这个功能是通过读取服务器当前的数据库状态来实现。AOF 文件重写的过程是先从数据库中遍历读取键现在的值，然后用一条命令去吉利键值对代替之前记录的这个键值对的多条命令。

Redis AOF 文件重写是在子进程中完成的，这样可以同时达到两个目的：
- 子进程进行 AOF 重写期间，服务器进程(父进程)可以继续处理命令请求
- 子进程带有服务器进程的数据副本

子进程在进行 AOF 重写期间，服务器进程还需要继续处理命令请求，新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的 AOF 文件所保存的数据库转台不一致。Redis 服务器设置了一个 AOF 重写缓冲区用于解决这种数据不一致问题，这个缓冲区在服务器创建子进程之后开始使用，当 Redis 服务器执行完一个命令之后，它会同时将这个命令发送给 AOF 缓冲区和 AOF 重写缓冲区，这样可以保证：
- AOF 缓冲区的内容会定期被写入和同步到 AOF 文件，对现有 AOF 文件的处理工作会如常进行
- 从创建子进程开始，服务器执行的所有写命令都会被记录到 AOF 重写缓冲区中

当子进程完成 AOF 重写之后向父进程发送一个信号，父进程在接收到该信号后调用信号处理函数执行以下工作：
- 将 AOF 重写缓冲区中的所有内容写入到新 AOF 文件中，这时新 AOF 文件所保存的数据库状态将和服务器当前的数据库状态一致
- 对新的 AOF 文件进行改名，原子的覆盖现有的 AOF 文件，完成新旧两个 AOF 温家你的替换

父进程执行完信号处理函数之后就可以正常接受命令请求，在整个 AOF 重写过程中只有信号处理函数执行时会对服务器进程造成阻塞，在其他时候 AOF 重写都不会阻塞父进程，这将 AOF 重写对服务器性能造成的影响降到了最低。
#### AOF 配置
Redis 提供了多种将数据 fysnc 到磁盘上的选项：
- ```appendfsync always``` - 每次新命令追加到 AOF 时都会执行 fsync
- ```appendfsync everysec``` - 每秒 fysnc 一次
- ```appendfsync no``` - 不使用 fysnc
建议和默认的策略是每秒 fysnc，它非常快速且非常安全。
### 复制(replica)

**[Back](../)**
## 持久化

Redis 通过持久化机制保证数据不丢失，Redis 提供了 `RDB` 和 `AOF` 两种数据持久化的方式：

- `RDB`：以指定间隔将数据库在当前时间点的数据集以二进制文件的形式持久化到磁盘
- `AOF`：以追加文件的形式持久化写操作

Redis 可以通过不同的配置可以实现不同的持久化机制：

- 不启用持久化，此时一旦节点异常就会丢失数据
- 只启用 `RDB` 持久化方式，有丢失部分数据的风险
- 只启用 `AOF` 持久化方式，通过重放记录的命令来恢复数据，相对较慢且生成的文件较大
- 同时启用 `RDB` 和 `AOF` 文件，尽可能保证数据不丢失

#### RDB

`RDB` 持久化方式是在某个时间点生成数据集的快照，其有如下优势：

- 二进制文件结构紧凑，文件较小
- 适合灾备，可以将 rdb 文件作为备份存储在其他地方
- rdb 通过后台子进程生成二进制文件，不会阻塞对外提供服务的进程
- rdb 文件能够更快的恢复数据



### RDB 持久化
Redis 提供了 RDB 持久化功能，可以将 Redis 的内存中的数据库状态保存到磁盘避免数据意外丢失。RDB 持久化操作可以手动执行，也可以根据服务器配置选项定期执行，RDB 持久化将某个时间点上的数据库状态保存到一个 RDB 文件。
#### RDB 优势和劣势
RDB 是某个时间点上的数据库状态的数据快照，有如下优势：
- RDB 是一个非常紧凑的二进制文件，表示某一时刻 Redis 数据集的快照，RDB 文件非常适合用于备份
- RDB 非常适合灾备，可以将单个压缩文件传输到远端数据中心进行灾备
- RDB 不会影响 Redis 性能，因为 Redis 父进程仅仅是 fork 了一个子进程，而其他所有的持久化操作都是子进程完成的，父进程永远不会执行磁盘 IO
- 在数据量比较大的情况下，相较于 AOF，RDB 能更快的重启

RDB 也存在一些劣势：
- 如果需要在 Redis 停止工作时将数据丢失的可能性降到最低，RDB 并不是很好的选择，因为一般 RDB 的时间间隔比较久，这段时间内的数据变更将会丢失
- RDB 需要 fork 子进程才能将数据持久化到磁盘，当数据量很大时 fork 可能会非常耗时，并且如果 CPU 性能不佳可能会导致 Redis 停止服务几毫秒甚至一秒

当 Redis 需要 dump 数据到磁盘形成 RDB 文件时，会执行以下步骤：

- Redis 通过 fork 创建子进程
- 子进程将数据集写入到临时的 RDB 文件
- 子进程完成数据写入后就替换旧的 RDB 文件

#### RDB 配置
Redis 可以通过设置服务器的 save 选项让服务器每隔一段时间自动执行 BGSAVE 命令。默认情况下，Redis 将数据集快照存放在磁盘上名为 dump.rdb 的二进制文件中。可以在配置文件中设置数据集在 N 秒内有 M 个更改则 dump 一次数据集的快照：
```conf
dbfilename dump.rdb
save 900 1
save 300 10
save 60 10000
```
配置中只需要满足三个条件中的一个就会执行 BGSAVE 命令：
- 服务器在 900s 内对数据库进行了至少 1 次修改
- 服务器在 300s 内对数据库进行了至少 10 次修改
- 服务器在 60s 内对数据库进行了至少 10000 次修改
### AOF 持久化
除了 RDB 持久化之外，Redis 还提供了 AOF(Append Only File)持久化功能，与 RDB 持久化通过保存数据库中的键值对来记录数据库状态不同，AOF 持久化时通过保存 Redis 服务器所执行的命令来记录数据库状态的。

#### AOF 优势和劣势
AOF 的优势：
- AOF 持久化能保证更少的数据丢失，AOF 支持多种 fsync 策略：不使用 fsync；每秒 fsync；每次查询都 fsync；即使使用 Redis 默认的策略，即每秒 fsync，Redis 性能仍然很好，因为使用后台线程执行 fsync
- AOF 是一个追加日志，因此掉电也不会有搜索或者损坏问题，即使由于某些原因(磁盘已满)日志以半写命令结束，redis-check-aof 工具也能够轻松修复
- 当 AOF 太大时，Redis 会自动在后台重写 AOF；重写是完全安全的，因为当Redis继续附加到旧文件时，使用创建当前数据集所需的最小操作集生成一个全新的文件，并且一旦第二个文件准备就绪，Redis会切换两个并开始附加到新的那一个
- AOF 以易于理解和解析的格式将所有操作记录在日志中，AOF 日志可以轻松的导出用于恢复数据集


AOF 的劣势：
- AOF 文件通常比同一数据集的 RDB 文件大
- AOF 在某些 fsync 策略下可能会比 RDB 慢，一般来说即使设置每秒 fsync 性能也是非常高的

#### AOF 持久化实现
AOF 持久化功能的实现可以分为命令追加(append)、文件写入、文件同步三个步骤。

当 AOF 持久化功能处于打开状态时，服务器会在执行完一个写命令之后以协议格式将被执行的写命令追加到服务器状态的 aof_buf 缓冲区的末尾。

Redis 服务进程是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求以及向客户端发送命令回复，时间事件负责执行定时运行的函数。服务器每次结束一个事件循环之前都会调用 flushAppendOnlyFile 函数考虑是否需要将 aof_buf 缓冲区中的内容写入和保存到 AOF 文件里面，flushAppendOnlyFile 函数的行为由服务器配置的 appendfsync 选项值来决定。

#### AOF 文件载入和数据还原
因为 AOF 文件包含了重建数据库状态所需的所有命令，因此服务器只需要服务并重新执行一遍 AOF 文件中保存的所有命令就可以还原服务器关闭之前的数据库状态。

Redis 读取 AOF 文件并还原数据库状态的详细步骤：
- 创建一个不带网络连接的伪客户端。因为 Redis 的命令只能在客户端上下文中执行，而载入 AOF 文件时所使用的命令直接来源于 AOF 文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行 AOF 文件保存写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一致
- 从 AOF 文件中分析并读取一条写命令
- 使用伪客户端执行被读出的写命令
- 重复执行读取写命令和执行写命令直到 AOF 文件中的所有写命令都被处理完为止
#### AOF 重写
随着写操作的执行，AOF 文件将会越来越大，Redis 支持在后台重建 AOF 而不会中断对客户端的服务。通过这个功能 Redis 可以创建一个新的 AOF 文件来替换现有的 AOF 文件，两个 AOF 文件保存的数据库状态相同但新的 AOF 文件不会包含任何浪费空间的冗余命令。

AOF 文件重写并不需要对现有的 AOF 文件进行任何读取、分析或写入操作，这个功能是通过读取服务器当前的数据库状态来实现。AOF 文件重写的过程是先从数据库中遍历读取键现在的值，然后用一条命令去吉利键值对代替之前记录的这个键值对的多条命令。

Redis AOF 文件重写是在子进程中完成的，这样可以同时达到两个目的：
- 子进程进行 AOF 重写期间，服务器进程(父进程)可以继续处理命令请求
- 子进程带有服务器进程的数据副本

子进程在进行 AOF 重写期间，服务器进程还需要继续处理命令请求，新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的 AOF 文件所保存的数据库转台不一致。Redis 服务器设置了一个 AOF 重写缓冲区用于解决这种数据不一致问题，这个缓冲区在服务器创建子进程之后开始使用，当 Redis 服务器执行完一个命令之后，它会同时将这个命令发送给 AOF 缓冲区和 AOF 重写缓冲区，这样可以保证：
- AOF 缓冲区的内容会定期被写入和同步到 AOF 文件，对现有 AOF 文件的处理工作会如常进行
- 从创建子进程开始，服务器执行的所有写命令都会被记录到 AOF 重写缓冲区中

当子进程完成 AOF 重写之后向父进程发送一个信号，父进程在接收到该信号后调用信号处理函数执行以下工作：
- 将 AOF 重写缓冲区中的所有内容写入到新 AOF 文件中，这时新 AOF 文件所保存的数据库状态将和服务器当前的数据库状态一致
- 对新的 AOF 文件进行改名，原子的覆盖现有的 AOF 文件，完成新旧两个 AOF 温家你的替换

父进程执行完信号处理函数之后就可以正常接受命令请求，在整个 AOF 重写过程中只有信号处理函数执行时会对服务器进程造成阻塞，在其他时候 AOF 重写都不会阻塞父进程，这将 AOF 重写对服务器性能造成的影响降到了最低。
#### AOF 配置
Redis 提供了多种将数据 fysnc 到磁盘上的选项：
- ```appendfsync always``` - 每次新命令追加到 AOF 时都会执行 fsync
- ```appendfsync everysec``` - 每秒 fysnc 一次
- ```appendfsync no``` - 不使用 fysnc
建议和默认的策略是每秒 fysnc，它非常快速且非常安全。

**[Back](../)**
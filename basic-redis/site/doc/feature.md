
## Redis Pipelining
Redis 是使用 client-server 模型和 Request/Response 协议的 TCP 服务器，这意味这每次请求都会有以下步骤：
- 客户端向服务器发送查询，并通常以阻塞的方式从 Socket 中读取服务器的响应
- 服务器处理该命令并将响应发送回客户端

客户端和服务器是通过网络来连接的，这种连接可能非常快也可能非常慢，但是无论是何种连接，请求数据包从客户端到服务器然后响应数据包从服务器返回到客户端都是需要时间的，这个时间就成为 RTT(Round Trip Time)。当客户端需要连续执行多个请求时就会严重影响 Redis 的吞吐量，Redis Piplining 解决了这种问题。

Redis Pipelining 通过实现在客户端还没有读取响应数据就处理下一个请求来提升服务器的吞吐量，这样就可以将多个命令发送到服务器而无需等待回复，最后只需一步即可读取全部响应。

当客户端使用 Pipelining 发送命令的时候，服务器将强制使用内存对请求进行排队，因此如果需要使用 Pipelining 发送大量的命令，需要设置一个比较合理的批次。

Pipelining 技术不仅解决了 RTT 耗时，而且也大大提高了 Redis 服务器每秒可执行的操作量。这是因为，在不使用 Pipelining 的情况下，Socket I/O 操作是非常昂贵的，因为涉及到 read() 和 write() 系统调用，也就意味着用户进程和内核进程的切换，这个切换在速度上代价非常大。使用 Pipelining 操作，使用单个 read() 系统调用执行多个请求命令，并使用单个 write() 系统调用返回多个响应。因此每秒执行的总查询数会随着 Pipelining 的长度线性增加并最终达到不使用 Pipelining 的 10倍。

## Redis 事务

**[Back](../)**
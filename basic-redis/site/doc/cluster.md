## 集群

Redis Cluster 是 Redis 的分布式实现，其提供了两种能力：

- 自动将数据分片到不同节点的能力
- 部分节点异常时继续提供服务的能力

Redis Cluster 的每个节点需要占用两个端口：

- 用于为客户端提供服务的端口，如 6379
- 用于集群内部进行故障检测、配置更新、故障转移等的端口(提供服务的端口值 + 10000)，如 16379

### 数据分片

Redis 没有使用一致性 hash 算法，而是使用了哈希槽(`hash slot`) 的概念来将数据分片到集群中的各个节点。集群将整个 key 空间划分为 `16384` 个槽，集群中的所有 key 通过映射算法映射到槽中：

```
HASH_SLOT = CRC16(KEY) mod 16384
```

每个节点处理哈希槽的一个子集，在没有发生哈希槽迁移时，每个哈希槽只会由一个节点负责。只有在所有的槽都有对应的节点处理，整个集群才处于上线状态，否则即使有一个槽没有得到处理整个集群也处于下线状态。

Redis Cluster 采用的哈希槽分片方式使得增加节点和删除节点比较方便：增加节点时只需要将其他节点的哈希槽迁移到新的节点；删除节点前将节点上的数据迁移到其他节点。

哈希槽的迁移不需要停止服务，在哈希槽迁移的过程中集群依然可以对外提供服务。

### 可用性

Redis 集群使用主从模型保证可用性，每个哈希槽有 `1~N` 个副本，当主节点无法提供服务时，从节点就会被选举为新的主节点对外提供服务，如果从节点也无法提供服务则整个集群无法对外提供服务。

集群中的每个节点都会定期向集群中的其他节点发送 `PING` 消息，如果接收 PING 消息的节点没有在规定的时间内返回 PONG 消息，那么发送 PING 消息的节点就会将接收 PING 消息的节点标记为疑似下线(probable fail, PFAIL)。

集群中的各个节点会通过互相发送消息交换集群中各个节点的状态信息，如果一个集群中半数以上负责处理槽的主节点都将某个主节点 x 报告为疑似下线，那么这个主节点 x 将被标记为以下线(FAIL)，将主节点 x 标记为已下线的节点会向集群广播关于节点 x 的 FAIL 消息，所有接收到这条消息的节点(包括 replica 节点)会立即将主节点 x 标记为下线

### 一致性

Redis 主从之间采用的是异步复制，因此 Redis 不能保证数据的强一致性，也就是写入的数据有可能会丢失。Redis 集群数据丢失有两种情况：

- 写入主节点的数据还未复制到从节点就异常，此后从节点选举为主节点导致数据丢失。这种情况比较少见，因为主节点在回复客户端和复制到从节点几乎是同时发生的
- 网络分区主节点写入了数据，在解决网络分区后主节点变为从节点则会导致写入的数据丢失。Redis 主节点在 `NODE_TIMEOUT` 时间内未能与大多数主节点建立通信则会被认为失效，此时集群会触发故障转移机制，该主节点也会拒绝后续的数据写入请求，但是在这段时间内写入的数据

### 故障转移

当一个 replica 节点发现自己的 master 节点进入已下线状态就会开始对下线的 master 节点进行故障转移：

- 从 replica 集合中选取一个结点
- 被选中的节点执行 ```slaveof no one``` 命令成为新的主节点
- 新的主节点将旧的主节点的槽指派给自己
- 新的主节点向集群广播一条 PONG 消息告知其他节点主节点的变更
- 新的主节点开始接收和处理负责的槽相关的请求命令，故障转移完成

新的主节点的选举过程：

- 集群的 config-epoch 是一个自增计数器，初始值为 0
- 当集群的某个结点开始一次故障转移时，config-epoch 的值会加 1
- 对于每个 config-epoch 集群里每个负责处理槽的主节点都有一次投票的机会，第一个向主节点要求投票的从节点将获得主节点的投票
- 当从节点发现自己的 master 节点进行下线状态时会立即向集群中广播一条 ```CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST``` 消息，要求所有接收到这条消息且具有投票权的主节点向这个从节点投票
- 如果一个主节点具有投票权并且这个主节点尚未投票给其他从节点，那么该主节点就会向要求投票的从节点返回一条 ```CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK``` 消息表示主节点支持该从节点成为新的主节点
- 每个参与选举的从节点都会接收 ```CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK``` 消息并根据自己接收到了多少条这种消息来统计自己获得了多少主节点的支持
- 如果集群里有 N 个具有投票权的主节点，那么当一个从节点收集到大于等于 N/2+1 个投票时，这个从节点就会当选为新的主节点
- 如果在一个 config-epoch 里面没有从节点能收集到足够多的投票，那么集群会进入下一个新的 config-epoch 并再次进行选举直到选举出新的主节点为止

### 集群通信

#### 集群协议

集群中所有的节点使用 TCP 和二进制的协议(Redis 集群总线)互相连接，节点之间使用 gossip 协议传播集群的信息以便发现新的节点，发送 ping 数据包确保其他节点工作正常以及发送集群特定条件下的信号；集群总线还用于在集群间传播 pub/sub 消息。

Redis 集群没有代理，因此使用重定向错误 -MOVED 和 -ASK 将客户端的请求重定向到其他节点；理论上，Redis 客户端可以自由的向集群中所有的节点发送请求并在需要的时候重定向，因此客户端不需要保存集群的状态，但是如果客户端能够缓存 key 和集群节点的映射关系，那么可以提升查询性能。

#### 集群拓扑

Redis 集群是一个完整的网络，其中每个节点使用TCP连接与每个其他节点连接；在N个节点的集群中，每个节点具有N-1个传出TCP连接和N-1个传入连接，这些TCP连接始终保持活动状态，不按需创建。当节点期望在响应集群总线中的ping时发出pong应答时，在等待足够长的时间以将节点标记为不可达之前，它将尝试通过从头开始重新连接来刷新与节点的连接。当Redis Cluster节点形成一个完整的网格时，节点使用 gossip 协议和配置更新机制，以避免在正常情况下在节点之间交换太多消息，因此交换的消息数量不是指数级的。

#### 节点握手

节点始终接受群集总线端口上的连接，甚至即使ping节点不受信任也会回复收到的 ping。但是，如果发送节点不被视为群集的一部分，则接收节点将丢弃所有数据包。

节点以两中方式接受一个节点作为集群的一部分：

- 节点发送 MEET 信息来表名自己；MEET 信息和 ping 信息完全相同，但是强制接收者接受发送消息的节点作为集群的一部分；当且仅当系统管理员使用 ```cluster meet <ip> <port>``` 命令时节点才会发出 meet 消息到其他节点将该结点加入到当前节点的集群
- 已经信任的节点向其他节点告知新的节点，那么这个节点将会被注册为集群的一部分。即如果 A 知道 B，并且 B 知道 C，B 向 A 发送 C 的信息，则 A 就会将 C 注册为集群的一部分并尝试与 C 连接。因此只需要使新加入的节点连接上集群中的任意一个节点，它们将最终自动的形成完全连接的图；这意味着集群能够自动发现其他节点，前提是系统管理员建立了信任关系

### MOVED 重定向

Redis 客户端可以自由的向集群中的任意节点发送查询，包括从节点。

节点分析查询，如果是可接受的(单个 key 或者多个 key 是相同的 hash 槽)则会查找负责该 hash 槽的节点，如果该节点负责处理处理 hash 槽则直接处理返回结果，否则在节点内部查找负责 hash 槽的节点，返回 MOVE 错误给客户端。

MOVE 错误包括 key 对应的 hash 槽和提供查询的节点的 ip 和 port，客户端需要重新查询新的节点，如果在此期间集群发生变更导致 hash 槽变化，则依然会再次返回 MOVE 错误

### ASK 重定向

在进行重分片期间，源节点向目标节点迁移一个槽的过程中可能会出现一种情况：属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对保存在目标节点里面。

当客户端向源节点发送一个命令需要处理的键恰好属于正在被迁移的槽时：

- 如果源节点能在自己的数据库中查找到指定的键，则直接执行客户端发送的命令
- 如果源节点不能再自己的数据库中查找到指定的键，则向客户端返回 ASK 错误并重定向到正在迁移的槽的目标节点

接收到 ASK 错误的客户端会根据错误提供的 IP 地址和端口转向至正在导入槽的目标节点，然后首先向目标节点发送 ASKING 命令，然后再重新发送原本想要执行的命令。如果没有发送 ASKING 命令而直接发送需要指定的命令，目标节点会拒绝执行并返回 MOVED 错误。

ASK 错误和 MOVED 错误的区别：

- MOVED 错误代表槽的负责权已经从一个结点转移到了另一个节点；客户端收到关于槽 slot 的 MOVED 错误之后所有关于 slot 槽的命令都可以直接发送到 MOVED 错误指定的节点
- ASK 错误只是两个节点在迁移槽的过程中使用，当客户端收到关于槽 slot 的 ASK 错误后只有接下来的一次请求会发送到 ASK 错误指定的节点，后续的操作还是会请求到源节点

### 集群配置
Redis 的配置文件 redis.conf 可以配置集群的参数：
- ```cluster-enabled <yes/no>``` - 如果设置为 true，则该节点作为 Redis 集群的一个节点
- ```cluster-config-file <filename>``` - 该文件是集群节点发生变化时集群节点自动持久化集群配置的文件，以便能够在集群重启时重启读取；该文件列出了集群中的其他节点、节点的状态、持久变量等；该文件用户不可编辑
- ```cluster-node-timeout <milliseconds>``` - Redis 集群被视为不可用前不可用的最长时间；如果主节点的不可访问时间超过这个时间，则其从节点将进行故障转移
- ```cluster-slave-validity-factor <factor>``` - 如果设置为 0，则从节点无论主从之间连接断开的时间长短都会尝试进行故障转移；如果设置为正数，则计算节点的最大超时时间然后乘以 factor，如果节点是从节点，则在主从断开连接时间超过该值之前，从节点不会发起失效转移
- ```cluster-migration-barrier <count>``` - 与主节点保持连接的最小从节点数量，以便于一个从节点迁移到没有从节点的主节点
- ```cluster-require-full-coverage <yes/no>``` - 如果设置为 true(默认为 true)，则当一定比例的 key 空间不在任何一个节点上，节点将会停止接受写入；如果设置为 false，即使是只能处理部分子集，查询操作仍将支持
#### 创建集群
在创建集群之前需要创建 Redis 实例，配置集群相关参数并启动实例
```conf
port 7000
cluster-enabled yes
cluster-config-file nodes-7000.conf
cluster-node-timeout 5000
```
启动 Redis 实例：
```shell
../redis-server ./redis-7000.conf
```
创建 Redis 集群，Reids 5 提供了命令行工具，而 Redis 3 和 Redis 4 需要使用 redis-trib.rb 脚本创建集群
```shell
-- redis 5
redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 ... \
--cluster-replicas 1

-- redis 4
./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 ...
```
#### 集群重新分片
重新分片意味着一些哈希槽会从一个节点迁移到其他节点，可以使用命令行实现
```shell
redis-cli --cluster reshard <host>:<port> \
--cluster-from <node-id> --cluster-to <node-id>
--cluster-slots <number of slots> --cluster-yes
```
#### 添加新结点
添加新节点基本上就是添加空节点然后将一些数据移入其中(如果是主节点)或者设置为已知节点的副本(如果是从节点)的过程。
##### 添加主节点
- 创建新节点，和创建集群一样创建新的节点

- 使用命令行工具向集群中添加新的节点
  ```shell
  # 第一个参数为新加入集群的节点，第二个参数为集群中任意一个节点
  redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000
  ```
  
- 连接新节点查看是否加入集群
  ```shell
  cluster nodes
  ```

由于新节点已经加入了集群，因此它能够正确的重定向客户端的查询，并且已经成为集群的一部分；但是和其他主节点相比，它有几个特征：

- 没有数据，因为它没有分配哈希槽
- 因为是没有分配哈希槽的主节点，所以当从节点切换为主节点时它不参与选举过程，可以使用重新分片功能为此节点分配哈希槽

##### 添加从节点
添加从节点和添加主节点只是在 redis-cli 的参数上有所不同
```shell
# 指定为随机一个主节点的从节点
redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000 --cluster-slave

# 指定为特定主节点的从节点
redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000 --cluster-slave --cluster-master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e
```
#### 移除节点
移除节点直接使用命令行工具：
```shell
# 第一个参数为集群任意节点，第二个参数是删除节点的 id
redis-cli --cluster del-node 127.0.0.1:7000 <node-id>
```
这种方式也可以用于删除主节点，但是主节点在删除之前必须是空的，否则需要将数据重新分片到其他主节点；也可以在一个从节点上执行手动故障转移并在节点从主节点变为从节点后将其删除。
#### 迁移从节点
使用命令行工具可以随时迁移一个从节点到另一个主节点：
```shell
cluster replicas <master-node-id>
```
在某些情况下，从节点可以自动迁移到主节点下能够提升 Redis 集群的稳定性。当一个主节点的从节点故障时，多个从节点中的一个就会迁移到这个主节点下，这样即使主节点发生故障也能通过选举从节点来继续提供服务。
- 集群会尝试从拥有最多从节点的主节点下迁移从节点
- 从节点迁移是自动的，因此在向集群中添加节点的时候随机指定从节点的主节点就行
- redis.conf 中的 cluster-migration-barrier 可以控制副本的迁移

**[Back](../)**
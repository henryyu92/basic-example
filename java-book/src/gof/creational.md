## 创建型模式

创建型模式是用来创建对象的模式，抽象了实例化的过程。所有的创建型模式都有两个主要功能：

- 将系统所使用的具体类的信息封装起来
- 隐藏类的实例是如何被创建和组织的，外界对于这些对象只知道共同的接口，而不知道具体的实现细节

创建型模式在创建什么 (what) 、由谁创建 (who)、何时创建 (when) 这些方面为软件设计者提供了尽可能大的灵活性。创建型模式的作用可以概括为两点：

- 封装创建逻辑，而不是直接实例化对象
- 封装创建逻辑的变化，使得客户端代码尽量不修改或者少修改

### 单例模式

单例模式确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

单例模式的优点：

- 内存中只会有一个实例，减少了频繁创建、销毁对象的开销
- 当创建对象的操作比较重时使用单例模式可以减少由于创建对象的开销

### 工厂方法模式

工厂作为抽象类，实际的创建工作将由其具体子类完成。工厂方法的用意是定义一个创建产品对象的工厂接口，将实际的创建工作推迟到子类中去，强调的是 "单个对象" 的变化。

- 简单工厂模式：工厂类处于对产品类实例化的中心位置，知道每个产品并决定那个产品类应当被实例化。在增加产品类时需要修改工厂类，不满足 "开闭原则"
- 工厂方法模式：核心的工厂类不再负责所有产品的创建，而是将具体的创建工作交由子类去做，工厂类仅负责给出具体工厂必须实现的接口

```java
public interface Creator<T extends Product>{
    T getProduct();
}
```

工厂方法模式优点：

- 优秀的可扩展性，在增加产品类的情况下，只要适当地修改具体的工厂类或扩展一个工厂类就可以适应变化
- 客户端不用关心产品的变化，只要接口不变，使用产品对应的工厂类即可得到对应的产品

### 抽象工厂模式

抽象工厂可以向客户提供一个接口，使得客户可以在不必指定产品具体类型的情况下，创建多个产品族中的产品对象，强调的是 "系列对象" 的变化。

```java
public interface AbstractFactory {
    ProductA createA();
    ProduceB createB();
}

public class ConcreteFactory1 implements AbstractFactory {
    public ProductA createA(){return new ProductA1();}
    public ProductB createB(){return new ProductB1();}
}
```

### 建造者模式

把构造对象实例的逻辑移到了类的外部，在类的外部定义了该类的构造逻辑。它把一个复杂对象的构造过程从对象的表示中分离出来，其直接效果将一个复杂的对象简化为一个比较简单的目标对象，强调的是产品的构造过程。

创建者模式的优点：

- 封装对象创建的过程，将对象创建过程作为整体
- 在对象创建过程复杂的场景下比较有用

### 原型模式

同样对客户隐藏了对象的创建工作，但与通过对一个类进行实例化来构造新的对象不同的是，原型模式是通过复制一个现有对象生成新对象。
## 并发安全

当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

保证对象是线程安全有两种方案：

- **对象不可变**：对象在初始化之后其内部状态则不会发生变化，如果共享数据是一个基本数据类型，则只需要在定义时使用 final 关键字即可保证其不可变；如果共享数据是一个对象，则需要保证对象的行为不会对其状态产生任何影响
- **使用同步措施**：同步措施通过使用加锁或者 CAS 的方式保证线程在并发使用数据时只能有一个线程成功，从而保证共享数据的线程安全

### 非阻塞同步

非阻塞同步基于冲突检测的乐观并发策略，也就是先尝试进行操作，如果有其他线程竞争导致操作失败则采用其他补偿措施 (通常是不断的重试直到成功)。非阻塞同步不需要将操作失败的线程挂起。

 `CAS` 是常见的非阻塞同步方式，`CAS` 指令需要 3 个操作数，分别是内存位置 V、旧的预期值 A 和新值 B。`CAS` 指令执行时，当且仅当 V 符合旧预期值 A 时，处理器用新值 B 更新 V 的值，否则不执行更新，无论更新是否完成都会返回 V 的旧值 A，这个过程是一个原子操作。

CAS 从语义上来说存在 ABA 问题：如果一个变量 V 初次读取的时候是 A，并且在准备赋值的时候检测到它仍然为 A，这个期间如果它的值被更改为 B 然后在更改为 A 则 CAS 操作会误认为这个值从来没有改变过，通过一个带版本的变量可以保证 CAS 的正确性。

### 互斥同步

采用 cas 的非阻塞同步在线程竞争激烈时会存在大量的自旋，浪费 CPU 资源。通过互斥同步的方式在线程访问共享变量之前以阻塞的方式获取锁对象，并且在使用完共享变量之后释放锁对象。

Java 中最基本的互斥同步手段是使用 `synchronized` 关键字，其底层原理是在同步代码块前后生成字节码指令，使得线程在进入同步代码块之前需要获取锁对象，并且在退出同步代码块时释放锁对象。

### synchronized

`synchronized` 关键字是 Java 提供的阻塞式的同步组件，`synchronized` 关键字在经过编译后会在同步块的前后分别形成 `monitorenter` 和 `monitorexit` 这两个字节码指令，这两个字节码都需要一个 reference 类型的参数来指明要锁定和解锁的对象。 `synchronized` 关键字在使用时需要指定锁定的对象：

```java
// 锁对象为当前 Class 对象
public static synchronized test(){}

// 锁对象为当前实例对象
public synchronized test(){}

// 锁对象为指定的对象
synchronized(lock){}
```

虚拟机规范要求在执行 `monitorenter` 指令时，首先要尝试获取指定的对象的锁，如果这个对象没有锁定或者当前线程已经拥有了对象的锁，则把锁的计数器加 1，相应的在执行 `monitorexit` 指令时计数器就减 1，当计数器为 0 时锁就被释放；如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。

每个对象都有一个 monitor 监视器，当 monitor 被占用时就会处于锁定状态，线程执行 `monitorenter` 指令时尝试获取 monitor 的所有权：
- 如果 monitor 没有被占用，则当前线程获得 monitor 的所有权，并将获取锁的次数 +1
- 如果 monitor 已经被占用但是当前线程重入，则依然可以进入同步代码块，获取锁的次数 +1
- 如果 monitor 被其他线程占用，则当前线程进入阻塞状态，直到 monitor 被获取的次数为 0 后再次尝试获取锁

`synchonized` 同步块对同一个线程来说是可重入的，不会出现自己把自己锁死的问题，同步块在已进入的线程执行完之前会阻塞后面其他线程的进入。

**阻塞或者唤醒线程需要从用户态切换到核心态，状态间的转换需要耗费很多处理器的时间，因此 synchronized 被视为是 Java 中的重量级锁**。

### Mark Word

`Mark Word` 是 Java 对象头中的一部分，其中记录了对象的线程锁状态。`Mark Word` 中使用了 2 bit 记录了锁的三种状态：

- `00`：轻量级锁，`Mark Word` 中保存指向线程栈中的拷贝
- `01`：偏向锁，`Mark Word` 中保存了持有偏向锁的线程 ID
- `10`：重量级锁，`Mark Word` 中保存了指向监视器对象的指针

### 偏向锁

偏向锁的目的是消除在无竞争情况下的同步原语，提高程序的运行性能。

偏向锁假定没有其他线程获取锁，因此在线程第一次获取锁时会把锁对象的 `MarkWord` 中的标志位设置为 01，同时使用 CAS 操作把获取到这个锁的线程 ID 记录在锁对象的 Mark Word 中，如果 CAS 操作成功则表示当前线程持有偏向锁，线程以后每次进入这个锁相关的同步块时虚拟机都可以不再进行任何同步操作而只需要简单的测试一下对象头的 Mark Word 中的线程 ID 是否是当前线程的 ID。

偏向锁使用一种等到竞争出现才释放锁的机制，当其他线程尝试获取偏向锁时，当前持有偏向锁的线程才会释放锁，此时偏向锁膨胀为轻量级锁。

### 轻量级锁

轻量级锁应用在对象虽然被多个线程访问，但是线程访问的时间是错开的，也就是没有锁竞争。`JVM` 使用轻量级锁在没有多线程竞争的前提下减少重量级锁使用操作系统互斥量产生的性能消耗。

- 在线程进入同步代码块的时候，如果此同步对象没有被锁定(锁定标志位为 01 状态)，虚拟机首先在当前线程的栈帧中建立一个 Lock Record 的空间用于存储锁对象目前的 Mark Word 的拷贝 Displaced Mark Word。
- 虚拟机将使用 CAS 操作尝试将锁对象的 Mark  Word 更新为指向 Lock Record 的指针，如果更新动作成功则这个线程拥有了该对象的锁并且对象的 Mark Word 锁标志转变为 00，即表示此对象处于轻量级锁定状态；
- 如果更新失败虚拟机会检查锁对象的 Mark Word 是否指向当前线程的栈帧，如果是则说明当前线程拥有了这个对象的锁。否则说明这个锁对象已经被其他线程抢占了，轻量级锁会膨胀成重量级锁，锁标志状态值变为 10，Mark Word 存储的就是指向重量级锁的指针，当前线程会尝试使用自旋来获取锁，而其他线程则会进入阻塞状态。

轻量级锁的解锁过程也是通过 CAS 操作进行的，如果对象的 Mark Word 仍然指向着线程的 Lock Record，那就用 CAS 操作把对象当前的 Mark Word 和线程中复制的 Displaced Mark Word 替换回来，如果替换成功整个同步过程就结束，如果替换失败则说明有其他线程尝试过获取锁，那就要在释放锁的同时唤醒被挂起的线程。

如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥量的开销；如果存在锁竞争，除了互斥量的开销外还额外发生了 CAS 操作；因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。

### 自旋

互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程需要转入内核态中完成，这些操作给系统的并发性能带来的很大的压力。

**自旋锁技术让需要获取锁的线程执行一个忙循环(自旋)而等待一段时间看持有锁的线程会不会释放锁，这样就可以避免挂起线程导致用户态和内核态的切换**。

自旋是自适应的，如果线程刚刚自旋成功获取过锁，则认为自旋获取锁的可能性较高，因此会多自旋几次，反之则少自旋几次。

自旋虽然可以避免线程切换的开销，但是需要占用 CPU 时间，因此如果锁被占用的时间很短自旋等待比较适用，但是如果锁被占用的时间很长则会消耗CPU 资源而浪费性能。

### 锁消除

锁消除是指虚拟机即时编译器在运行时对一些代码上要求同步但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中堆上所有的数据都不会逃逸出去从而被其他线程访问到，那么就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁无需进行。
```java
// StringBuffer 的 append 方法会加锁，
// 如果 StringBuffer 是局部变量则不需要加锁，编译器在编译的时候会消除加在上面的锁
public void test(){
    StringBuffer buf = new StringBuffer();
    buf.append("t1").append("t2");
    System.out.println(buf.toString());
}
```
### 锁粗化

如果一系列的连续操作都对同一个对象反复加锁和解锁，那么即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展(粗化)到整个操作序列外部。
```java
// f1 和 f2 都会对同一个锁作加锁&解锁动作，锁会粗化到 f
public void f(){
  f1();
  f2();
}

public synchronized void f1(){}

public synchronized void f2(){}
```

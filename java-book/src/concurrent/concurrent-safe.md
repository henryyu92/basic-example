## 并发安全

当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

- **不可变**：不可变对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施；Java 语言中如果共享数据是一个基本数据类型，则只需要在定义时使用 final 关键字即可保证其不可变；如果共享数据是一个对象，则需要保证对象的行为不会对其状态产生任何影响。
- **绝对线程安全**：要求一个类达到不管运行时环境如何，调用者都不需要任何额外的同步措施，基本上很难达到
- **相对线程安全**：相对线程安全保证这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用就可能需要在调用端使用额外的同步手段保证调用的正确性。
- **线程兼容**：线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确的使用同步手段来保证对象在并发环境中可以安全的使用；Java 中大部分类都是属于线程兼容的。
- **线程对立**：线程对立是指无论调用端是否采用了同步措施，都无法在多线程环境中并发使用的代码，这种情况很少出现。

### 互斥同步

同步是指在多个线程并发访问共享数据是，保证共享数据在同一时刻只被一个(或者多个)线程使用。Java 中最基本的同步手段是使用 synchronized 关键字，synchronized 关键字在经过编译后会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码都需要一个 reference 类型的参数来指明要锁定和解锁的对象；如果程序中的 synchronized 明确指定了对象参数，那么锁对象就是这个对象，如果没有则需要根据 synchronized 修饰的是实例方法还是类方法去取对应的对象实例或 Class 对象作为锁对象。

根据虚拟机规范的要求，在执行 monitorenter 指令时，首先要尝试获取对象的锁，如果这个对象没有锁定或者当前线程已经拥有了对象的锁，则把锁的计数器加 1，相应的在执行 monitorexit 指令时计数器就减 1，当计数器为 0 时锁就被释放；如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。

synchonized 同步块对同一个线程来说是可重入的，不会出现自己把自己锁死的问题；同步块在已进入的线程执行完之前会阻塞后面其他线程的进入。**如果要阻塞或者唤醒一个线程需要从用户态切换到核心态，状态间的转换需要耗费很多处理器的时间，因此 synchronized 是 Java 语言中的一个重量级操作**。

java.util.concurrent 包中的重入锁（ReentrantLock）也可以实现同步，ReentrantLock 和 synchronized 相比增加了一些高级功能：
- 等待可中断：等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情
- 公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁，非公平锁则是在锁释放时任何一个等待锁的线程都有机会获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是可以设置为公平锁
- 锁可以绑定多个条件：锁绑定多个条件是指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象

### 非阻塞同步

互斥同步最大的问题是进行线程阻塞和唤醒带来的性能问题，因此也称为阻塞同步。非阻塞同步是基于冲突检测的乐观并发策略，也就是先进行操作，如果没有其他线程争用共享数据那操作就成功了，如果共享数据有争用则采用其他的补偿措施(常见的就是不断的重试直到成功)，这种并发策略的许多实现不需要把线程挂起。

CAS 指令需要 3 个操作数，分别是内存位置 V、旧的预期值 A 和新值 B。CAS 指令执行时，当且仅当 V 符合旧预期值 A 时，处理器用新值 B 更新 V 的值，否则不执行更新，无论更新是否完成都会返回 V 的旧值 A，这个过程是一个原子操作。CAS 从语义上来说存在 ABA 问题：如果一个变量 V 初次读取的时候是 A，并且在准备赋值的时候检测到它仍然为 A，这个期间如果它的值被更改为 B 然后在更改为 A 则 CAS 操作会误认为这个值从来没有改变过，通过一个带版本的变量来保证 CAS 的正确性。

### 无同步

同步是保证共享数据争用时的正确性，如果不存在共享数据就不需要任何同步措施去保证正确性。

### synchronized
Java 中的每一个对象都可以作为 synchronized 的锁：
- 普通方法使用的是当前实例作为锁
- 静态方法使用当前类的 Class 对象作为锁
- 同步代码块使用 synchronized 配置的对象作为锁

synchronized 的是使用 monitorenter 和 monitorexit 指令表示进入和退出锁对象来实现同步。monitorenter 指令是在编译后插入到同步代码块的开始位置，而 monitorexit 插入到代码块结束的处和异常处，JVM 保证每个 monitorenter 必须有对应的 monitorexit。

每个对象都有一个 monitor 监视器，当 monitor 被占用时就会处于锁定状态，线程执行 monitorenter 指令时尝试获取 monitor 的所有权：
- 如果 monitor 没有被占用，则当前线程获得 monitor 的所有权，并将获取锁的次数 +1
- 如果 monitor 已经被占用但是当前线程重入，则依然可以进入同步代码块，获取锁的次数 +1
- 如果 monitor 被其他线程占用，则当前线程进入阻塞状态，直到 monitor 被获取的次数为 0 后再次尝试获取锁

### Mark Word
JVM 对象头中的 Mark Word 表示锁对象，Mark Word 中的数据会随着锁标识位的变化而变化：
```
  +----------+----------------+--------------+------------+---------+
  |          |   25 bit       |              | 1 bit      | 2 bit   |
  | 锁状态   +--------+-------+  4 bit       +------------+---------+
  |          | 32 bit | 2 bit |              | 是否偏向锁 | 锁标志位 |
  +----------+--------+-------+--------------+-----------+----------+
  | 轻量级锁 | 指向栈中锁记录的指针                        | 00       |
  +----------+-------------------------------------------+----------+
  | 重量级锁 | 指向互斥量(重量级锁)的指针                  | 10       |
  +----------+-------------------------------------------+----------+
  | GC 标记  | 空                                        | 11       |
  +----------+---------+------+--------------+-----------+----------+
  | 偏向锁   | 线程 ID | Epoch | 对象分代年龄 | 1         | 01       |
  +----------+---------+------+--------------+-----------+----------+

```
通过代码判断 Mark Word 中的标志位得到当前锁的状态，从而减少 CPU 用户态和内核态的切换带来的性能损耗。Java 中的锁有四种状态：无锁状态、偏向锁状态、轻量级锁状态 和 重量级锁状态，**锁可以升级但是不能降级**。

### 自旋锁

互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程需要转入内核态中完成，这些操作给系统的并发性能带来的很大的压力。在许多应用上，共享数据的锁定状态只会持续很短一段时间，**自旋锁技术让需要获取锁的线程执行一个忙循环(自旋)而等待一段时间看持有锁的线程会不会释放锁，这样就可以避免挂起线程导致用户态和内核态的切换**；JVM 提供了 ```-XX:+UseSpinning``` 参数来开启自旋锁，默认是开启的。

自旋虽然可以避免线程切换的开销，但是需要占用 CPU 时间，因此如果锁被占用的时间很短自旋等待比较适用，但是如果锁被占用的时间很长则会消耗CPU 资源而浪费性能。JVM 提供了 ```-XX:PreBlockSpin=10``` 来指定自旋的次数，如果超过这个值则会使用传统的方式挂起线程，默认是 10 次。

JDK 1.6 引入了自适应的自旋锁，意味着自旋的时间不再固定而是由上一次在同一个锁上自旋的时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得锁并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间；如果对于某个锁自旋很少成功获得过，那么以后要获取这个锁时可能省略掉自旋的过程避免浪费 CPU 资源。

### 偏向锁

偏向锁的目的是消除在无竞争情况下的同步原语，进一步提高程序的运行性能。轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，偏向锁是在无竞争的情况下把整个同步和 CAS 都消除掉。

偏向锁会偏向第一个获得它的线程，如果在接下来的执行过程中该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。

当虚拟机启用了偏向锁(-XX:+UseBiasedLocking，默认开启)，那么当锁对象第一次被线程获取的时候虚拟机将会把对象头中的标志位设置为 01，同时使用 CAS 操作把获取到这个锁的线程 ID 记录在对象的 Mark Word 中，如果 CAS 操作成功则表示当前线程持有偏向锁，线程以后每次进入这个锁相关的同步块时虚拟机都可以不再进行任何同步操作而只需要简单的测试一下对象头的 Mark Word 中的线程 ID 是否是当前线程的 ID。

偏向锁使用一种等到竞争出现才释放锁的机制，当其他线程尝试获取偏向锁时，当前持有偏向锁的线程才会释放锁。偏向锁的撤销根据持有锁的线程的状态恢复到未锁定状态或者轻量级锁状态。

### 轻量级锁

轻量级锁不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下减少重量级锁使用操作系统互斥量产生的性能消耗。

在线程进入同步代码块的时候，如果此同步对象没有被锁定(锁定标志位为 01 状态)，虚拟机首先在当前线程的栈帧中建立一个 Lock Record 的空间用于存储锁对象目前的 Mark Word 的拷贝 Displaced Mark Word。虚拟机将使用 CAS 操作尝试将锁对象的 Mark  Word 更新为指向 Lock Record 的指针，如果更新动作成功则这个线程拥有了该对象的锁并且对象的 Mark Word 锁标志转变为 00，即表示此对象处于轻量级锁定状态；如果更新失败虚拟机会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是则说明当前线程拥有了这个对象的锁，否则说明这个锁对象已经被其他线程抢占了，则当前线程会尝试使用自旋来获取锁。如果有两个以上的线程争用同一个锁，那么轻量级锁就不再有效，锁标志状态值变为 10，Mark Word 存储的就是指向重量级锁的指针，后面等待锁的线程也要进入阻塞状态。

轻量级锁的解锁过程也是通过 CAS 操作进行的，如果对象的 Mark Word 仍然指向着线程的 Lock Record，那就用 CAS 操作把对象当前的 Mark Word 和线程中复制的 Displaced Mark Word 替换回来，如果替换成功整个同步过程就结束，如果替换失败则说明有其他线程尝试过获取锁，那就要在释放锁的同时唤醒被挂起的线程。

轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥量的开销；如果存在锁竞争，除了互斥量的开销外还额外发生了 CAS 操作；因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。

### 锁消除

锁消除是指虚拟机即时编译器在运行时对一些代码上要求同步但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中堆上所有的数据都不会逃逸出去从而被其他线程访问到，那么就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁无需进行。
```java
```
### 锁粗化

如果一系列的连续操作都对同一个对象反复加锁和解锁，那么即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展(粗化)到整个操作序列外部。
```java
// f1 和 f2 都会对同一个锁作加锁&解锁动作，锁会粗化到 f
public void f(){
  f1();
  f2();
}

public synchronized void f1(){}

public synchronized void f2(){}
```
*[Back](../)*
## 垃圾收集

Java 运行时区域中的程序计数器、虚拟机栈、本地方法栈的生命周期都会伴随着线程的生命周期，在线程结束时会自动回收内存，因而不需要考虑内存回收的问题。而Java 堆中对象的创建和回收是在程序运行时动态确定的，垃圾收集关注的正是这部分内存的管理。

### 垃圾收集对象

垃圾收集器在进行内存回收之前，需要确定对象是否已经不被任何途径使用，确定对象没有被引用有两种算法：引用计数和可达性分析。

#### 引用计数算法

引用计数算法给每个对象添加一个引用计数器，每当一个地方引用它时计数器值加 1，当引用失效时计数器值减 1，任何时候计数器值为 0 的对象就是不可能被再使用的。

引用计数算法实现简单，效率也很高，但是该算法很难解决对象之间的循环引用问题。

#### 可达性分析算法

可达性分析算法以一系列的 `GC Roots` 对象作为起始点开始根据引用关系向下搜索，搜索所走过的路径称为引用链（Reference Chain），如果某个对象到 `GC Roots` 没有任何引用链，即从 `GC Roots` 到该对象是不可达的，则该对象是不可用的。

Java 中可作为 `GC Root` 的对象有：
- 虚拟机栈中引用的对象，如局部变量、临时变量等
- 方法区中静态属性引用的对象，如引用类型的静态变量
- 方法区中的常量引用的对象
- 本地方法栈中引用的对象

#### 对象引用

无论是通过引用计数算法判断引用的数量还是通过可达性分析算法判断对象的引用链是否可达，判断对象是否存活都与对象的引用有关，JVM 对引用的概念分为四种：
- **强引用(Strong Reference)** ： 直接赋值的引用都是强引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象
- **软引用(Soft Reference)**：  对于软引用关联的对象，系统在即将发生内存溢出之前，把这些对象列入回收范围之内进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常；jdk 提供 `SoftReference` 类实现软引用。
- **弱引用(Weak Reference)**：  被弱引用关联的对象只能生存到下一次垃圾收集发生之前；当垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象；jdk 提供 `WeakReference` 类实现弱引用
- **虚引用(Phantom Reference)**： 对象是否有虚引用的存在完全不会影响该对象的生存时间，也无法通过虚引用获取对象的实例。为对象设置虚引用的唯一目的就是能在这个对象被垃圾收集器回收时收到一个系统通知；jdk 提供 `PhantomReference` 类实现虚引用

### 垃圾收集算法

虚拟机遵循“分代收集”的理论设计，根据分代理论收集器应该将 Java 堆划分出不同的区域，然后回收对象依据其年龄(对象熬过垃圾收集过程的次数)分配到不同的区域之中存储。

为了防止老年代对象引用新生代对象使得在进行 Minor GC 的时候需要遍历老年代的对象确保可达性分析的正确性，新生代上会建立一个全局的数据结构记忆集(Remembered Set)把老年代分成若干块，标识出老年代的哪一块会存在跨代引用，在发生 Minor GC 时只有包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描。这种方法需要在对象改变引用关系(例如属性赋值)时维护记录数据的正确性需要增加额外的运行时开销，但是这些开销远小于扫描整个老年代的开销。

Minor GC/Young GC 是新生代的垃圾收集，其收集目标为新生代中的对象；Major GC/Old GC 是老年代的垃圾收集，即收集的目标是老年代中的对象，目前只有 CMS 收集器会单独收集老年代；Full GC 是指收集整个 Java 堆和方法区

#### 标记-清除算法

标记-清除(Mark-Sweep)算法分为标记和清除两个阶段：标记阶段标记出所有存活对象，清除阶段回收所有未被标记的对象。

标记-清除算法主要有两个缺点：如果堆中需要回收的对象较多，则标记和清除两个阶段的执行效率随着对象数的增长而降低；另外一个就是在标记和清除阶段完成后会产生大量不连续的内存碎片，内存碎片过多会导致在分配大对象时由于没有足够的连续内存分配而再次触发一次垃圾收集动作。

#### 标记-复制算法

标记-复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这块内存用完就将存活的对象复制到另一块内存上，然后将当前内存块清理。

标记-复制算法会产生对象内存间复制的开销，对于只有少量对象存活的情况而言简单高效。缺点就是每次都只使用一半的内存，存在比较大的空间浪费。

虚拟机实现的新生代垃圾收集器大多采用这种收集算法，在实际实现时将新生代划分为一块较大的 Eden 区和两块较小的 Survivor 区，每次分配内存只使用 Eden 区和其中的一块 Survivor 区，发生垃圾收集时将存活的对象复制到另一块 Survivor 区，然后清理掉已经使用的区域。Eden 区和 Survivor 区的大小比例通过参数 ```-XX:SurvivorRatio=8``` 来设置，HotSpot 虚拟机默认的 Eden 区和 Survivor 区的大小比例是 8:1，即 Eden 区占整个新生代的 80%，只有 10% 的空间浪费。

当 Survivor 区大小不足以容纳一次 Minor GC 后存活的对象时，就会发生分配担保(Handle Promotion)，即这些对象会直接进入老年代。

#### 标记-整理算法

标记-复制算法在存活对象较多时需要进行较多的复制操作效率较低，并且在存活对象较多时有触发分配担保的可能，因此标记-复制算法不适用于老年代。

标记-整理算法和标记-清除算法一样需要标记和清除两个阶段，但是在标记阶段完成之后不是直接清除可回收对象，而是将存活对象移动到内存的一端，然后清除掉剩余的内存。

标记-整理算法需要移动存活对象，移动对象时需要更新所有引用这些对象的地方，这是一项非常负重的操作而且整个移动操作过程中必须停止用户进程，这种停止所有用户进程的停顿称为 Stop The World(STW)。

标记-清除算法不需要额外的操作，因此垃圾收集停顿的时间较短，但是由于内存碎片问题会增加垃圾收集的频率，因此吞吐量会较低；标记-整理算法需要额外的操作，因此垃圾收集停顿的时间较长，而由于不会发生频繁的垃圾收集，因此吞吐量较高。HotSpot 虚拟机中关注吞吐量的 Parallel Old 收集器采用的是标记-整理算法，而关注停顿时间的 CMS 收集器采用的是标记-清除算法。

### HotSpot 算法实现

虚拟机在进行垃圾收集时需要实现可达性分析以及垃圾收集算法，HotSpot 虚拟机根据这些算法原理提供了高效的实现。

#### 根节点枚举

可达性分析算法需要从 GC Root 集合开始通过引用链的方式找到存活对象，GC Root 节点主要在全局性的引用(常量和静态变量)和执行上下文中，在实际中由于可以作为 GC Root 的节点非常的多，如果逐个从这些节点开始搜索则会消耗大量的时间。

在 HotSpot 的实现中可达性分析算法耗时最长的查找引用链的过程可以和用户线程一起并发执行，但是在根节点枚举必须在一个一致性的快照中执行，因此在根节点枚举的过程中需要暂停用户线程，即 Stop The World。

HotSpot 虚拟机使用一组称为 OoMap 的数据结构来存放对象的引用而不用检查所有执行上下文和全局的引用位置。


#### 安全点

在 OoMap 的协助下，HotSpot 虚拟机可以快速准确地完成 GC Roots 枚举，HotSpot 虚拟机在特定地位置记录这些信息，这些位置称为安全点(Safepoint)。

用户程序执行时必须到达安全点后才能够暂停，因此安全点不能太少以至于垃圾收集地时间过长，也不能太多以至于垃圾收集过于频繁，一般在方法调用、循环跳转、异常跳转等地方才会产生安全点。

线程在安全点停顿采用的是主动式中断(Voluntary Suspension)，即当垃圾收集需要中断线程的时候不直接对线程操作，而是设置一个标志位，各个线程在执行过程中会不停主动轮询这个标志，一旦发现中断标志为真时就会主动在最近的安全点上中断挂起。

#### 安全区域

安全点机制保证程序执行时在不太长的时间内就会遇到可进入垃圾收集的安全点，但是如果程序由于 sleep 或者 blocked 状态无法响应虚拟机的中断请求，不能在短时间内到安全点中断挂起时，虚拟机不可能一直等待，这是需要安全区域(Safe Region)来解决。

安全区域是指在一段代码片段中引用关系不会发生变化，在这个片段内任意地方开始的 GC 都是安全的。

当线程执行到安全区域里面的代码时，就标识自己已经进入安全区域，这样当虚拟机发起垃圾收集时就不必去管这些已经声明自己在安全区域内的线程了。当线程即将离开安全区域时要检查系统是否已经完成了根节点枚举或者其他需要暂停用户线程的阶段，如果完成就可以继续运行，否则需要等待直到收到可以离开安全区的信号为止。

#### 记忆集和卡表

记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构，垃圾收集器通过记忆集判断出某一块非收集区域是否存在有指向了手机区域的指针。

卡表是记忆集的一种具体实现，定义了记忆集的记录精度、与堆内存的映射关系等。

// todo

#### 并发的可达性分析

// todo 三色标记

并发标记的过程是和用户线程并发进行的，在并发扫描时用户线程改变了对象的引用关系则会导致对象消失的问题，解决这个问题有两种方案：增量更新(Incremental Update) 和 原始快照(Snapshot At The Beginning, SATB)。

增量更新是当黑色对象插入新的指向白色对象的引用时，就记录这个新插入的引用，并发扫描结束后以这些记录的引用关系中的黑色对象为根重新扫描一次，则白色对象就会变为灰色对象。

原始快照是当灰色对象要删除指向白色对象的引用关系时，就记录这个要删除的引用，并发扫描结束后以这些记录的引用关系中的灰色对象为根重新扫描一次。

CMS 是基于增量更新来做并发标记的，G1 是使用原始快照的方式来实现并发标记。

### 垃圾收集器

垃圾收集器是垃圾收集算法的具体实现，HotSpot 虚拟机实现了多种垃圾收集器，分别作用与不同分代。通过组合这些垃圾收集器可以完成整个堆的垃圾收集。

垃圾收集器组合：
- Serial + Serial Old
- ParNew + CMS + Serial Old
- Parallel Scavenge + Serial Old/Parallel Old
- G1
- ZGC

#### Serial 收集器

Serial 垃圾收集器采用标记-复制垃圾收集算法，使用单线程进行垃圾收集，也就是说 Serial 垃圾收集器使用一个线程收集垃圾，并且在进行垃圾收集时，必须暂停所有的工作线程直到垃圾收集结束。

![Serial 收集器](../../resources/serial.png)

Serial 收集器相关 JVM 参数：
- ```-XX:+UseSerialGC```：表示新生代使用 Serial 收集器进行垃圾收集
- ```-XX:PretenureSizeThreshold=n```：设置直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象直接在老年代分配，如 -XX:PretenureSizeThreshold=3145728(而不是 3m)
- ```-XX:MaxTenuringThreshold=15```：设置对象经过多少次 minor gc 之后进入老年代，默认 15

#### ParNew 收集器

ParNew 垃圾收集器是 Serial 垃圾收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为（包括控制参数、收集算法等）和 Serial 收集器完全一样。ParNew 收集器是使用了 -XX:+UseConcMarkSweepGC 后默认的新生代垃圾收集器。

![ParNew 收集器](../../resources/parNew.png)

ParNew 收集器相关 JVM 参数：
- ```-XX:+UseParNewGC```：表示新生代使用 ParNew 收集器进行垃圾收集
- ```-XX:PretenureSizeThreshold=n```：设置直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象直接在老年代分配，如 -XX:PretenureSizeThreshold=3145728(而不是 3m)
- ```-XX:MaxTenuringThreshold=15```：设置对象经过多少次 minor gc 之后进入老年代，默认 15
- ```-XX:ParallelGCThreads=10```：指定 ParNew 收集器进行垃圾收集的线程数，默认和 CPU 核数相同

#### Parallel Scavenge 收集器

Parallel Scavenge 收集器也是使用标记-复制算法，也是并行的多线程收集器，它和其他收集器的区别在于其他收集器是尽可能的缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标是达到一个可控的吞吐量(用户线程执行时间/(用户线程执行时间 + 垃圾收集时间))，从而高效的利用 CPU 时间。

停顿时间越短就越适合需要与用户交互的程序(用户线程能够快速响应)，而高吞吐量可以高效的利用 CPU 时间尽快完成程序的计算任务，主要适合运行在后台运算而不需要太多交互的任务。

Parallel Scavenge 垃圾收集器相关 JVM 参数：
- ```-XX:+UseParallelGC```：表示新生代使用 Parallel Scavenge 垃圾收集器
- ```-XX:MaxGCPauseMillis=n```：设定 GC 的最大时长(ms)，收集器尽可能的保证内存回收的时间不超过设定值，代价是垃圾回收变得频繁而降低吞吐量
- ```-XX:GCTimeRatio=99```：设置垃圾收集时间占总时间的比率；如设置为 19 则允许的最大 GC 时间占总时间的 5%（即 1/(1+19)），默认值是 99（即允许最大 1% 的垃圾收集时间）
- ```-XX:+UseAdaptiveSizePolicy```：开启自适应调节参数就不需要手工指定新生代大小(-Xmn)、eden 和 survivor 的比例(-XX:SurvivorRatio)、晋升老年代年龄(-XX:MaxTenuringThreshold) 等细节参数了，虚拟机会根据当前系统运行情况自动调节

#### Serial Old(MSC) 收集器

Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用”标记-整理“算法；主要用于 作为 CMS 收集器的后备预案，在发生 Concurrent Mode Failure 时使用；


#### Parallel Old 收集器

Parallel Old 是 Parallel Scavenge 的老年代版本，使用多线程和“标记-整理”算法；在注重 CPU 性能和吞吐量的环境中，优先使用 Parallel Scavenge + Parallel Old 组合，能达到吞吐量最优化。

![Parallel Old 收集器](../../resources/parallel_old.png)

Parallel Old 收集器相关 JVM 参数：
- ```-XX:+UseParallelOldGC```：老年代使用 Parallel Old 收集器进行垃圾收集

#### CMS 收集器

CMS(Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。CMS 收集器是基于“标记-清除”算法实现，具体分为四个阶段：
- 初始标记(CMS initial mark)：**初始标记需要 “Stop The World”**，它仅仅是标记一下 GC Root 能直接关联到的对象，速度很快；
- 并发标记(CMS concurrent mark)：并发标记进行 GC Roots Tracing 的过程，比较耗时，但是并发标记可以和用户线程一起工作，所以并不会影响 GC 时间
- 重新标记(CMS remark)：**重新标记也需要 “Stop The World”**，是为了修正并发标记期间因用户线程继续运行而导致标记产生变动的那部分对象的标记记录，停顿时间比初始标记稍长
- 并发清除(CMS concurrent sweep)：并发清除阶段是清除被标记的对象，可以和用户线程一起工作

并发标记和并发清除这两个阶段比较耗时，但是由于可以和用户线程一起工作，因此 CMS 收集器的内存回收时间很短暂。

![CMS 收集器](../../resources/cms.png)

CMS 垃圾收集器也有明显的缺点：
- CMS 收集器对 CPU 资源非常敏感，因为在并发阶段会占用一部分线程，会导致应用程序变慢(线程之间切换)，降低总吞吐量；CMS 默认启动的回收线程为 （CPU 数量 + 3）/4
- CMS 收集器无法处理浮动垃圾，可能出现 Concurrent Mode Failure 失败从而导致另一次 Full GC。在并发清除阶段，用户线程还在运行，这段时间内产生的垃圾只能等待下一次 GC 才能处理，这一部分垃圾称为浮动垃圾。在垃圾收阶段用户线程还在运行，所以需要预留一些内存空间给用户线程使用，如果预留内存不够，则会发生 Concurrent Mode Failure，这时候虚拟机将会临时启用 Serial Old 收集器作为老年代的垃圾收集器，这样就会使垃圾收集时间变得很长。CMS 收集器参数 ```-XX:CMSInitiatingOccupancyFraction=68``` 参数来设置当老年代空间使用的比例达到这个阈值时会触发垃圾收集
- CMS 收集器使用“标记-清除”算法进行垃圾回收，会导致大量内存空间碎片产生，从而导致分配大对象时无法找到足够的连续内存而不得不触发一次 Full GC。

CMS 收集器相关 JVM 参数：
- ```-XX:+UseConcMarkSweepGC```：启用 ParNew + CMS + Serial Old 的收集器组合进行内存回收。Serial Old 收集器作为 CMS 收集器出现 Concurrent Mode Failure 时的后备收集器
- ```-XX:CMSInitiatingOccupancyFraction=68```：设置触发 CMS 垃圾收集的老年代内存空间比例(即老年代内存空间使用比例高于这个参数时会触发 GC)，默认 68%；
- ```-XX:+UseCMSCompactAtFullCollection```：设置 CMS 收集器在 Full GC(老年代 GC) 之后进行一次内存碎片的合并整理过程，该过程无法并发，所以需要停顿的时间会变长；默认是开启
- ```-XX:CMSFullGCsBeforeCompaction=0```：设置执行多少次 Full GC 之后进行次带压缩的 Full GC，默认为 0，即每次 Full GC 时都进行了碎片整理
- ```-XX:ParallelCMSThreads=10```：设置 CMS 垃圾收集的线程数，默认为 CPU 核数

#### Garbage First 收集器

G1 收集器将整个 Java 堆划分为多个大小相等的独立区域(Region)，每个 Region 都可以根据需要为新生代的 Eden 区、Survivor 区或者老年代，收集器能够对不同角色的 Region 采用不同的策略去处理。

Region 中还有一类专门用于存储大对象的 Humongous 区域，只要对象大小超过了 Region 容量的一般则被认为是大对象。每个 Region 的大小可以通过参数 ```-XX:G1HeapRegionSize``` 设定，G1 将 Humongous Region 作为老年代的一部分看待。

G1 以 Region 作为每次回收的最小单元，即每次收集到的内存空间都是 Region 大小的整数倍，这样可以有计划的避免在整个堆中进行全区域的垃圾收集。

G1 收集器跟踪各个 Region 里面垃圾堆积的价值大小(回收所获得的空间大小以及回收所需要的时间的经验值)在后台维护一个优先列表，每次根据允许的垃圾收集时间(参数 ```-XX:MaxGCPauseMillis=200``` 指定)优先回收价值最大的 Region，这种回收方法保证了 G1 收集器在有限的时间内获取尽可能高的收集效率。

G1 收集器的特点：
- 并行和并发：G1 垃圾收集器可以使用多个 CPU 来缩短 Stop-The-World 停顿时间；部分其他收集器需要停顿 Java 线程执行 GC 动作，G1 仍然可以通过并发的方式让 Java 程序继续执行
- 分代收集：G1 收集器中依然有分代的概念，但是 G1 不需要和其他收集器配合就能独立管理整个 GC 堆
- 空间整合：G1收集器不会产生空间碎片，有利于程序长时间运行，分配大对象时不会因为没有足够的连续内存而提前触发下一次 GC
- 可预测停顿：G1 收集器除了追求低停顿外，还能建立可预测的停顿模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒

G1 垃圾收集器的收集过程分为四个阶段：
- **初始标记(Initial Marking)**：仅仅只是标记一个 GC Roots 能够直接关联到的对象，并且修改 TAMS(Top at Mark Start) 的值，让下一阶段用户线程并发运行时能够在正确可用的 Region 中创建对象，这个阶段需要停顿用户线程，但是时间很短
- **并发标记(Concurrent Maarking)**：从 GC Roots 开始对堆中的对象进行可达性分析，找出存活对象，耗时较长，但是可以和用户线程并发执行
- **最终标记(Final Marking)**：修正在并发标记期间因用户线程继续运行而导致标记产生变动的那一部分标记记录，需要停顿线程，但是可以并行执行
- **筛选回收(Live Data Counting and Evacuation)**：首先对各个的 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿来指定回收计划，将需要回收的 Region 中的存活对象复制到空的 Region 中，然后清理整个旧的 Region，这里需要移动存活对象，因此必须暂停用户线程

G1 垃圾收集器相关参数：
- ```-XX:+UseG1GC```：设置使用 G1 收集器进行垃圾收集
- ```-XX:G1HeapRegionSize=n```：设置 G1 Region 大小，每个 Region 大小可选范围 1m-32m，目标是根据最小的堆内存大小划分出约 2048 个 Region
- ```-XX:MaxGCPauseMillis=n```：设置垃圾回收的最大时间
- ```-XX:G1NewSizePercent=n```：设置新生代最小使用的空间比率，默认为 Java 堆内存的 5%
- ```-XX:G1MaxNewSizePercent=n```：设置新生代最大使用的空间比率，默认为 Java 堆内存的 6%
- ```-XX:ParallelGCThreads=n```：设置 STW 工作线程的数量，与使用的 CPU 数量有关，最大值是 8。如果 CPU 数据超过8，则最多可以设置总 CPU 数量的 5/8
- ```-XX:ConcGCThreads=n```：设置并行标记的线程数
- ```-XX:InitiatingHeapOccupancyPercent=n```：设置占用 Region 的百分比，超过此百分比将触发 GC 操作，默认为 45%
- ```-XX:G1ReservePercent=n```：设置预留空间的空闲百分比，以降低目标空间的溢出风险，默认为 10%

**[Back](../../)**
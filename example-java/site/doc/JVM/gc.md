## 垃圾收集
Java 程序计数器、虚拟机栈、本地方法栈的生命周期都会伴随着线程的生命周期，但是 Java 堆中对象的创建和回收是在程序运行时动态确定的，垃圾收集关注的正是这块内存。
### GC 对象
垃圾收集器在进行内存回收之前，需要确定对象是否已经不被任何途径使用，确定对象没有被引用有两种算法：引用计数和可达性分析。
#### 引用计数算法
给对象添加一个引用计数器，每当一个地方引用它时计数器值加 1，当引用失效时计数器值减 1，任何时候计数器值为 0 的对象就是不可能被再使用的。

引用计数算法实现简单，效率也很高，但是该算法很难解决对象之间的循环引用问题。
#### 可达性分析算法
以一系列的 GC Roots 对象作为起始点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链，即从 GC Roots 到该对象是不可达的，则该对象是不可用的。

在 JVM 中可作为 GC Root 的对象有：
- 虚拟机栈中引用的对象
- 方法区中静态属性引用的对象
- 方法区中的常量引用的对象
- 本地方法栈中引用的对象
#### 对象引用
无论是通过引用计数算法判断引用的数量还是通过可达性分析算法判断对象的引用链是否可达，判断对象是否存活都与对象的引用有关，JVM 对引用的概念分为四种：
- 强引用(Strong Reference) - 直接赋值的引用都是强引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象
- 软引用(Soft Reference) - 对于软引用关联的对象，系统在即将发生内存溢出之前，把这些对象列入回收范围之内进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常；jdk 提供 SoftReference 类实现软引用。
- 弱引用(Weak Reference) - 被弱引用关联的对象只能生存到下一次垃圾收集发生之前；当垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象；jdk 提供 WeakReference 类实现弱引用
- 虚引用(Phantom Reference) - 一个对象是否有虚引用的存在完全不会影响该对象的生存时间，也无法通过虚引用获取对象的实例。为一个对象设置虚引用的唯一目的就是能在这个对象被垃圾收集器回收时收到一个系统通知；jdk 提供 PhantomReference 类实现虚引用
### Stop-The-World
在虚拟机进行可达性分析的过程中，为了在一个确保一致性的快照中，此时所有线程都会暂停，这种现象称为 Stop-The-World；这也是导致 GC 进行时必须停顿所有的 Java 执行线程的一个重要原因。
### 安全点(Safepoint)
程序执行时并非在所有地方都能停顿下来开始 GC，只有在到达“特定的位置”才能暂停开始进行可达性分析，这些特定的位置称为安全点。

安全点不能太少(GC 停顿时间较长)也不能太多(GC 过于频繁)，一般在方法调用、循环跳转、异常跳转等地方会产生安全点。
### 安全区域
安全区是指在一段代码片段中，引用关系不会发生变化，在这个片段内任意地方开始的 GC 都是安全的；某些线程可能由于 sleep 或者 block 等原因不能及时运行到安全点，因此需要安全区来解决。

当线程执行到安全区时，就标识自己已经进入安全区，这样当 JVM 需要发起 GC 时就可以不用等待标识自己为安全区状态的线程了，当线程即将离开安全区时要检查系统是否已经完成了根节点枚举或者整个GC过程，如果完成就可以继续运行，否则需要等待直到收到可以离开安全区的信号为止。

### 垃圾收集算法
#### 标记-清除(Mark-Sweep)算法
标记-清除算法分为“标记”和“清除”两个阶段：
- 标记出所有需要回收的对象
- 标记完成后回收所有被标记的对象

标记-清除算法的最主要的缺点有两个：
- 标记和清除两个过程的效率不高
- 标记清除之后会产生大量的不连续的内存碎片，可能会导致垃圾收集之后程序在运行过程中需要分配较大对象时由于无法找到足够的连续空间而再次触发垃圾收集
#### 复制算法
复制算法将内存按容量划分为大小相等的两块，每次只使用其中的一块；当这一块内存使用完了，就将还存活的对象复制到另外一块内存上，然后将这块内存一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也不用考虑内存碎片的情况。

复制算法的缺点就是每次只使用一半的内存空间，浪费了内存。

实际实现时将内存分为一块较大的 eden 区和两块较小的 survivor 区，每次使用 eden 区和一块 survivor 区，当发生 GC 时，将存活对象复制到另一块 survivor 区，如果 survivor 区内存不够存储存活的对象，则这些对象进入老年代。
由于新生代 GC 之后存活对象较少，因此比较适合这种 GC 算法，Hotspot 虚拟机默认 eden 区和 survivor 区的大小比例为 8:1，即新生代只有 10% 的内存空闲
#### 标记-整理算法
标记-整理算法标记过程和“标记-清除”算法一样，但是在标记完成之后不是简单的清除未标记的对象，而是将所有存活对象压缩到内存的一端，清理边界外所有的空间。标记压缩之后，由于已用内存和可用内存是分开的，那么创建新对象时只需要简单的通过指针移动就可以开辟出相应的内存空间

### 垃圾收集器
垃圾收集器是垃圾收集算法的具体实现，不同的收集器实现了不同的垃圾收集算法。

垃圾收集器组合：
- Serial + CMS/Serial Old
- ParNew + CMS/Serial Old
- Parallel Scavenge + Serial Old/Parallel Old
#### Serial 收集器
Serial 垃圾收集器采用复制垃圾收集算法，使用单线程进行垃圾收集，也就是说 Serial 垃圾收集器使用一个线程收集垃圾，并且在进行垃圾收集时，必须暂停所有的工作线程直到垃圾收集结束。

![Serial 收集器](../../resources/serial.png)

Serial 收集器相关 JVM 参数：
- ```-XX:+UseSerialGC```：表示新生代使用 Serial 收集器进行垃圾收集
- ```-XX:PretenureSizeThreshold=n```：设置直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象直接在老年代分配，如 -XX:PretenureSizeThreshold=3145728(而不是 3m)
- ```-XX:MaxTenuringThreshold=15```：设置对象经过多少次 minor gc 之后进入老年代，默认 15
#### ParNew 收集器
ParNew 垃圾收集器是 Serial 垃圾收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为（包括控制参数、收集算法等）和 Serial 收集器完全一样。是大多数运行在 server 端模式的虚拟机中首选的新生代收集器，因为除了 Serial 收集器，只有 ParNew 收集器可以和 CMS 收集器配合工作。ParNew 收集器是使用了 -XX:+UseConcMarkSweepGC 后默认的新生代垃圾收集器。

![ParNew 收集器](../../resources/parNew.png)

ParNew 收集器相关 JVM 参数：
- ```-XX:+UseParNewGC```：表示新生代使用 ParNew 收集器进行垃圾收集
- ```-XX:PretenureSizeThreshold=n```：设置直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象直接在老年代分配，如 -XX:PretenureSizeThreshold=3145728(而不是 3m)
- ```-XX:MaxTenuringThreshold=15```：设置对象经过多少次 minor gc 之后进入老年代，默认 15
- ```-XX:ParallelGCThreads=10```：指定 ParNew 收集器进行垃圾收集的线程数，默认和 CPU 核数相同

#### Parallel Scavenge 收集器
Parallel Scavenge 收集器也是使用复制算法，也是并行的多线程收集器，它和其他收集器的区别在于其他收集器是尽可能的缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标是达到一个可控的吞吐量(用户线程执行时间/(用户线程执行时间 + 垃圾收集时间))，从而高效的利用 CPU 时间。

停顿时间越短就越适合需要与用户交互的程序(用户线程能够快速响应)，而高吞吐量可以高效的利用 CPU 时间尽快完成程序的计算任务，主要适合运行在后台运算而不需要太多交互的任务。

Parallel Scavenge 垃圾收集器相关 JVM 参数：
- ```-XX:+UseParallelGC```：表示新生代使用 Parallel Scavenge 垃圾收集器
- ```-XX:MaxGCPauseMillis=n```：设定 GC 的最大时长(ms)，收集器尽可能的保证内存回收的时间不超过设定值，代价是垃圾回收变得频繁而降低吞吐量
- ```-XX:GCTimeRatio=99```：设置垃圾收集时间占总时间的比率；如设置为 19 则允许的最大 GC 时间占总时间的 5%（即 1/(1+19)），默认值是 99（即允许最大 1% 的垃圾收集时间）
- ```-XX:+UseAdaptiveSizePolicy```：开启自适应调节参数就不需要手工指定新生代大小(-Xmn)、eden 和 survivor 的比例(-XX:SurvivorRatio)、晋升老年代年龄(-XX:MaxTenuringThreshold) 等细节参数了，虚拟机会根据当前系统运行情况自动调节
#### Serial Old(MSC) 收集器
Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用”标记-整理“算法；主要用于 作为 CMS 收集器的后备预案，在发生 Concurrent Mode Failure 时使用；
#### Parallel Old 收集器
Parallel Old 是 Parallel Scavenge 的老年代版本，使用多线程和“标记-整理”算法；在注重 CPU 性能和吞吐量的环境中，优先使用 Parallel Scavenge + Parallel Old 组合，能达到吞吐量最优化。

![Parallel Old 收集器](../../resources/parallel_old.png)

Parallel Old 收集器相关 JVM 参数：
- ```-XX:+UseParallelOldGC```：老年代使用 Parallel Old 收集器进行垃圾收集

#### CMS(Concurrent Mark Sweep) 收集器
CMS 收集器是一种以获取最短回收停顿时间为目标的收集器。CMS 收集器是基于“标记-清除”算法实现，具体分为四个阶段：
- 初始标记（CMS initial mark） - **初始标记需要 “Stop The World”**，它仅仅是标记一下 GC Root 能直接关联到的对象，速度很快；
- 并发标记（CMS concurrent mark）- 并发标记进行 GC Roots Tracing 的过程，比较耗时，但是并发标记可以和用户线程一起工作，所以并不会影响 GC 时间
- 重新标记（CMS remark）- **重新标记也需要 “Stop The World”**，是为了修正并发标记期间因用户线程继续运行而导致标记产生变动的那部分对象的标记记录，停顿时间比初始标记稍长
- 并发清除（CMS concurrent sweep）- 并发清除阶段是清除被标记的对象，可以和用户线程一起工作

并发标记和并发清除这两个阶段比较耗时，但是由于可以和用户线程一起工作，因此 CMS 收集器的内存回收时间很短暂。

![CMS 收集器](../../resources/cms.png)

CMS 垃圾收集器也有明显的缺点：
- CMS 收集器对 CPU 资源非常敏感，因为它会占用一部分线程，会导致应用程序变慢(线程之间切换)，降低总吞吐量；CMS 默认启动的回收线程为 （CPU 数量 + 3）/4
- CMS 收集器无法处理浮动垃圾，可能出现 Concurrent Mode Failure 失败从而导致另一次 Full GC。由于在并发清除阶段，用户线程还在运行，这段时间内产生的垃圾只能等待下一次 GC 才能处理，这一部分垃圾称为浮动垃圾。由于在垃圾收阶段用户线程还在运行，所以需要预留一些内存空间给用户线程使用，如果预留内存不够，则会发生 Concurrent Mode Failure 问题，这时候虚拟机将会临时启用 Serial Old 收集器作为老年代的垃圾收集器，这样就会使垃圾收集时间变得很长。
- CMS 收集器使用“标记-清除”算法进行垃圾回收，会导致大量内存空间碎片产生，从而导致分配大对象时无法找到足够的连续内存而不得不触发一次 Full GC。

CMS 收集器相关 JVM 参数：
- ```-XX:+UseConcMarkSweepGC```：启用 ParNew + CMS + Serial Old 的收集器组合进行内存回收。Serial Old 收集器作为 CMS 收集器出现 Concurrent Mode Failure 时的后备收集器
- ```-XX:CMSInitiatingOccupancyFraction=68```：设置触发 CMS 垃圾收集的老年代内存空间比例(即老年代内存空间使用比例高于这个参数时会触发 GC)，默认 68%；
- ```-XX:+UseCMSCompactAtFullCollection```：设置 CMS 收集器在 Full GC(老年代 GC) 之后进行一次内存碎片的合并整理过程，该过程无法并发，所以需要停顿的时间会变长；默认是开启
- ```-XX:CMSFullGCsBeforeCompaction=0```：设置执行多少次 Full GC 之后进行次带压缩的 Full GC，默认为 0，即每次 Full GC 时都进行了碎片整理
- ```-XX:ParallelCMSThreads=10```：设置 CMS 垃圾收集的线程数，默认为 CPU 核数

#### G1 垃圾收集器
G1 收集器将整个 Java 堆划分为多个大小相等的独立区域(Region)，新生代和老年代都是一部分 Region。G1 收集器跟踪各个 Region 里面垃圾堆积的价值大小(回收所获得的空间大小以及回收所需要的时间的经验值)在后台维护一个优先列表，每次根据允许的垃圾收集时间优先回收价值最大的 Region，这样 G1 收集器就能够避免在整个 Java 堆中进行安全域的垃圾收集，从而可以建立可预测的停顿时间模型。

G1 收集器的特点：
- 并行和并发：G1 垃圾收集器可以使用多个 CPU 来缩短 Stop-The-World 停顿时间；部分其他收集器需要停顿 Java 线程执行 GC 动作，G1 仍然可以通过并发的方式让 Java 程序继续执行
- 分代收集：G1 收集器中依然有分代的概念，但是 G1 不需要和其他收集器配合就能独立管理整个 GC 堆
- 空间整合：G1收集器不会产生空间碎片，有利于程序长时间运行，分配大对象时不会因为没有足够的连续内存而提前触发下一次 GC
- 可预测停顿：G1 收集器除了追求低停顿外，还能建立可预测的停顿模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒

G1 垃圾收集器的阶段：
- 初始标记(Initial Marking)：仅仅只是标记一个 GC Roots 能够直接关联到的对象，并且修改 NTAMS(Next Top at Mark Start) 的值，让下一阶段用户线程并发运行时能够在正确可用的 Region 中创建对象，这个阶段需要停顿用户线程，但是时间很短
- 并发标记(Concurrent Maarking)：从 GC Roots 开始对堆中的对象进行可达性分析，找出存活对象，耗时较长，但是可以和用户线程并发执行
- 最终标记(Final Marking)：修正在并发标记期间因用户线程继续运行而导致标记产生变动的那一部分标记记录，需要停顿线程，但是可以并行执行
- 筛选回收(Live Data Counting and Evacuation)：首先对各个的 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿来指定回收计划，需要停顿线程，但是可以并行执行

G1 垃圾收集器相关参数：
- ```-XX:+UseG1GC```：设置使用 G1 收集器进行垃圾收集
- ```-XX:G1HeapRegionSize=n```：设置 G1 Region 大小，每个 Region 大小可选范围 1m-32m，目标是根据最小的堆内存大小划分出约 2048 个 Region
- ```-XX:MaxGCPauseMillis=n```：设置垃圾回收的最大时间
- ```-XX:G1NewSizePercent=n```：设置新生代最小使用的空间比率，默认为 Java 堆内存的 5%
- ```-XX:G1MaxNewSizePercent=n```：设置新生代最大使用的空间比率，默认为 Java 堆内存的 6%
- ```-XX:ParallelGCThreads=n```：设置 STW 工作线程的数量，与使用的 CPU 数量有关，最大值是 8。如果 CPU 数据超过8，则最多可以设置总 CPU 数量的 5/8
- ```-XX:ConcGCThreads=n```：设置并行标记的线程数
- ```-XX:InitiatingHeapOccupancyPercent=n```：设置占用 Region 的百分比，超过此百分比将触发 GC 操作，默认为 45%
- ```-XX:G1ReservePercent=n```：设置预留空间的空闲百分比，以降低目标空间的溢出风险，默认为 10%

G1 采用了分区(Region)的思路，将整个堆空间分成若干个大小相等的内存区域，每次分配对象空间将逐段地使用内存。在堆的使用上，G1 并不要求对象的存储一定是物理连续的，只要逻辑上连续即可，每个 Region 可以按需在新生代和老年代切换，通过参数 ```-XX:G1HeapRegionSize=n``` 指定每个 Region 的大小(1M-32M)，默认将堆划分为 2048 个 Region。

每个分区内部又被分成了若干个大小为 512B 的卡片，标识为堆内存最小可用粒度。 

**[Back](../)**
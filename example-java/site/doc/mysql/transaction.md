## 事务
事务是一组原子性的 SQL 查询，如果其中任意一个语句因为崩溃或其他原因无法执行，也就是说事务内的语句，要么全部执行成功，要么全部执行失败。MySQL 中只有 InnoDB 存储引擎支持事务。

事务具有 ACID 特性：
- ```原子性(Automicity)```：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作
- ```一致性(Consistency)```：数据库总是从一个一致性的状态到另外一个一致性状态
- ```隔离性(Isolation)```：一个事务在最终提交之前，对其他事务是不可见的，隔离性受隔离级别影响
- ```持久性(Durability)```：一旦事务提交，则其所做的修改就会永久保存到数据库中，此时即使数据库崩溃，修改的数据也不会丢失

### 隔离级别
- ```读未提交(Read Uncommitted)```：在 Read Uncommitted 级别，事务中的修改即使没有提交，其他事务也是可见的。事务可以读取未提交的数据的情况被称为脏读(Dirty Read)
- ```读已提交(Read Committed)```：在 Read Committed 级别，一个事务开始直到提交之前所做的任何修改对其他事务来说是不可见的。这个级别解决了脏读的问题，但是在事务提交前后相同的查询会读到不同的数据，这种情况称为不可重复读(noRepeatable read)。
- ```可重复读(Repeatable Read)```：在 Repeatable Read 级别中，同一事务中多次读取同样的记录结果是一致的。这个级别解决了不可重复读的问题，但是当某个事务在读取某个范围内的纪录时，另外一个事务又在该范围内插入了新的记录，于是该事务再次读取这个范围时就会产生幻行(Phantom Row)，这种现象称为幻读(Phantom Read)。  
可重复读是 MySQL 的默认事务隔离级别。
- ```串行化(Serializable)```：Serializable 是最高的隔离级别，它通过强制事务串行执行，避免了幻读的产生。该级别会在读取每一行数据上都家所，所以可能导致大量的超时和锁争用的问题。

### 多版本并发控制(MVCC)
MySQL 的大多数事务型存储引擎实现的都不是简单的行级锁，基于性能的考虑一般都同时实现了多版本并发控制(MVCC)。MVCC 使得 InnoDB 的事务隔离级别下执行一致性读操作有了保证，也就是说为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值而不用等待事务执行完毕释放锁。

InnoDB 的 MVCC 在每行记录后面保存两个隐藏的列来实现的。这两个列分别保存行创建时的系统版本号和行删除时的系统版本号。每开始一个新的事务，系统版本号就会自动递增，此版本号也作为事务的版本号，用于查询时与行记录的版本号进行比较。

#### SELECT
InnoDB 在查询时会检查查询的每行记录，只有符合条件才能作为结果返回：
- InnoDB 只查找版本早于当前事务版本的行(也就是说，行的系统版本号小于或等于事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改的。
- 行的删除版本要么未定义(当前事务之后没有其他事务)，要么大于等于当前事务版本号(当前事务之后还有其他事务)，这样可以确保事务读取到的行在事务开始之前没有被删除。

#### DELETE
InnoDB 为删除的每一行保存当前系统版本号作为行删除标识
#### INSERT
InnoDB 为新插入的每一行保存当前系统版本号为行版本号
#### UPDATE
InnoDB 会插入一条新的记录，并且保存当前系统版本号为该记录的行版本号，同时保存当前系统版本号到原来的行作为行删除标识

保存额外的两个系统版本号，使得大多数读操作都可以不用加锁，但是由于每行记录都需要记录这两个版本号并且需要比较版本号，因此会消耗一定的存储空间和性能  

**MVCC 只在 Repeatable read 和 Read Commit 两个事务隔离级别下工作**
### 事务分类
从事务理论的角度来说，可以把事务分为几种类型：
- 扁平事务(Flat Transaction)：所有操作都处于同一层次，由 BEGIN 开始 COMMIT 或者 ROLLBACK 结束，其中的所有操作都是原子的，要么都执行要么都回滚
- 带保存点的扁平事务(Flat Transaction with Savepoint)：除了支持扁平事务外，允许在事务执行过程中回滚到同一事务中较早一个状态。保存点(Savepoint)用于记录事务的一个状态用于回滚
- 链事务(Chained Transaction)：在提交一个事务时释放不需要的数据对象，将必要的处理上下文隐式的传给下一个要开始的事务，提交事务的操作和开始下一个事务操作将合并为一个原子操作，着意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行的一样
- 嵌套事务(Nested Transaction)：嵌套事务是由若干事务组成的一棵树，子树既可以是嵌套事务也可以是扁平事务；叶节点的事务是扁平事务；根节点的事务是顶层事务，其他事务是子事务，子事务既可以提交也可以回滚，但是提交操作并不马上生效而是等到父事务提交才能生效；树中的任意一个事务的回滚会引起它所有的子事务一同回滚
- 分布式事务(Distributed Transaction)：通常是一个分布式环境下运行的扁平事务，因此需要根据数据所在的位置访问网络中的不同节点

### 事务实现
事务的原子性、一致性、持久性通过数据库的 redo log 和 undo log 来完成。 redo log 用来保证事务的原子性和持久性；undo log 用来保证事务的一致性。

redo log 是物理日志，记录的是页的物理修改操作，用于恢复提交事务修改的页操作；undo log 是逻辑日志，根据每行记录进行记录，用于回滚记录到某个特定的版本。

#### Redo Log
重做日志用来实现事务的持久性，由两部分组成：内存中的重做日志缓冲(redo log buffer)，其是易失的；重做日志文件(redo log file)，其是持久的。

InnoDB 是事务的存储引擎，当事务提交(commit)时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的 commit 操作完成才算完成。


#### Undo Log

undo 记录用于事务回滚的信息，存放在数据库内部位于共享表空间的一个称为 undo segment 中，undo log 是逻辑日志记录逻辑操作的反向操作，而 redo log 中记录操作后的数据


**[Back](../../)**
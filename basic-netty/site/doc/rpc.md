## RPC
RPC(Remote Procedure Call) 远程过程调用，是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。典型的 RPC 框架包括 Dubbo，Thrift，gRPC 等，其底层通信框架一般都选用 Netty。

RPC 中网络协议和网络 I/O 模型是透明的，传输层使用的是 TCP/UDP 还是 HTTP 协议对上层调用者来说是透明的。RPC 一般应该具有跨语言能力，RPC 通过网络调用远程计算机上的程序，无论远程程序使用什么语言开发都应调用成功。

网络传输的数据是二进制的，而 RPC 是方法调用，因此对于一个 RPC 框架来说必须包含**序列化/反序列化(serialize)**、**编解码(codec)**、**网络通信(network)**这几部分，同时为了向上层屏蔽底层实现以及跨语言，RPC 框架一般包含 **代理(Stub)** 和 **IDL** ，因此 RPC 框架的整体架构如下：

```

                            +-----------+
                            |     IDL   |
                            +-----------+
                                |   |
                                |   |
    +-------------------+       |   |           +-------------------+
    |     RPC Client    |       |   |           |     RPC Service   |
    +-------------------+       |   |           +-------------------+
              |                 |   |                     |
    +-------------------+       |   |           +-------------------+
    |     Proxy/Stub    |<------|   |---------->| Selector/Processor|
    +-------------------+                       +-------------------+
              |                                           |
    +-------------------+                       +-------------------+
    |  Message Protocol |                       |  Message Protocol |
    +-------------------+                       +-------------------+
              |                                           |
    +-------------------+                       +-------------------+
    | Transfer Protocol |                       | Transfer Protocol |
    +-------------------+                       +-------------------+
```
- Client：RPC 调用的发起方，一般而言对下层的通信细节无感知，通常对于有多种实现的业务来说可以通过注册中心获取所有的实现，从中选择需要调用的实现类
- Service：远程服务方法的具体实现，只和业务相关，对底层的通信细节无感知
- Proxy/Stub：PRC 代理存在于客户端，主要用于管理网络传输协议和消息的处理
- Message Protocol：客户端和服务端都存在，用于对网络传输的消息进行编码和解码，通过自定义消息格式及其编解码算法可以针对特殊场景大大增强性能
- Transfer Protocol：传输协议层负责管理 RPC 框架所使用的网络协议和网络 IO 模型，客户端和服务端的网络传输协议需要一致
- Selector/Processor：存在于 RPC 服务端，用于选择服务端提供的实现。包括管理 RPC 接口的注册、客户端的请求权限等
- IDL：IDL 并不是 RPC 实现中所必须的，但是 IDL 可以提供跨语言的特性

不同的 RPC 框架实现可以使用不同的 IDL 描述语言，不同的通信协议，不同的消息协议等，采用不同的实现会直接影响 RPC 框架的性能：
- 网络 IO 模型：RPC 通信可以采用同步阻塞式 IO，也可以使用多路 IO 复用，不同的网络 IO 模型在高并发下性能有很大差别
- 网络协议：RPC 可以使用基于 HTTP 的应用程协议，也可以使用基于 TCP/UDP 的传输层协议，目前主流的 RPC 框架使用的是基于 TCP 的传输协议
- 消息格式：RPC 是通过网络传输的，传输的是字节流，不同的消息格式影响框架的处理性能。消息格式的选用需要考虑：消息的易读性、消息体大小、编解码效率、拆包/粘包处理
- 序列化和反序列化：RCP 消息是以字节流的方式传输的，因此需要对消息进行序列化和反序列化，常用的有 Protobuf, Thrift, Avro, Hessian 等
- 服务管理方式：在高并发下，Selector/Processor 可以使用单线程运行服务具体实现，也可以采用每一个请求一个独立的线程运行，还可以采用线程池的方式来运行具体的服务实现

### 协议

RPC 一般采用 TCP 四层协议，TCP 协议是二进制协议，不能表示方法调用关系，因此需要在 TCP 协议之上自定义数据传输协议。

协议的设计需要满足高效、可扩展等性能，通常协议包含固定协议头、可变协议头、消息体三部分。一个具体的数据传输协议如下：

```
+-------+--------+-------------+---------+---------+-----------+--------+
| 0-15  |  16-47 |    48-63    |  64-71  |  72-79  |   80-87   |  88-87 |
+-------+--------+-------------+---------+---------+-----------+--------+
| magic | length | head length | version | version | serialize | msg id |
+-------+--------+-------------+---------+---------+-----------+--------+
| variable length|			extend head									|
+----------------+------------------------------------------------------+
| variable length|			message body								|
+----------------+------------------------------------------------------+
```

### 序列化

### 动态代理

### 服务发现

### 负载均衡

### 熔断限流







https://blog.csdn.net/yjp198713/article/details/79410521


https://www.cnblogs.com/ASPNET2008/p/6859211.html

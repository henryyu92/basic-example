## HTTP 协议

超文本传输协议(HyperText Transfer Protocol，HTTP) 是一种**应用层协议**，HTTP 协议是万维网的数据通信基础。

HTTP 协议采用了请求/响应模型，客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头和请求数据，服务器以一个状态行作为响应，响应的内容包括协议的版本、状态码、服务器信息、响应头和响应数据。

- HTTP 协议是基于请求-响应模式的，也就是说服务器端在没有接收到客户端发出的请求之前不会发送响应
- HTTP 协议是无状态的协议，即 HTTP 协议自身不对请求和响应之间的通信状态进行保存，HTTP1.1 增加了 Cookie 管理状态
- HTTP 协议是无连接的，即每次连接只处理一个请求，服务器处理完客户端的请求并收到客户端的应答后即断开连接，HTTP1.1 增加了 keep-alive 可以时服务端在返回响应之后保持连接一段时间

### 请求方法

HTTP/1.1 协议中共定义了八种方法来操作指定的资源：
- GET：GET 应该只用于读取数据，而不应当被用于产生“副作用”的操作中
- HEAD：不返回资源本身，而是返回资源的元数据信息
- POST：向指定资源提交数据，请求服务器处理，可能会创建新的资源或修改现有的资源
- PUT：向指定资源位置上传最新内容
- DELETE：删除指定位置的资源
- TRACE：回显服务器收到的请求，主要用于测试或诊断
- OPTIONS：使服务器传回该资源所支持的所有 HTTP 请求方法
- CONNECT：用于 SSL 加密服务器的连接

### 状态码

HTTP 响应的第一行是状态行，依次是 HTTP 版本号、状态码、状态描述，彼此使用空格分隔。

HTTP 响应的状态分为 5 类：
- 1xx：信息性状态码，表示接收的请求正在处理
- 2xx：成功状态码，表示请求处理完成
- 3xx：重定向状态码，表示资源已经被移动，客户端需要到新的资源地址获取
- 4xx：客户端错误状态码，表示服务器无法处理请求
- 5xx：服务器错误状态买，表示服务器处理请求出错

常见的状态码解释：
- 200：服务器成功处理了请求
- 301：资源被**永久**移除到其他位置，响应中需要包含资源新的地址
- 302：资源被**临时**移除到其他位置，响应中需要包含资源新的地址
- 304：表示客户端缓存的资源是最新的，客户端使用缓存即可。客户端在发送请求时将缓存中资源的最后修改时间发送给服务器端，服务器端如果发现资源未被修改则返回 304，否则返回 200 以及最新的资源
- 400：请求数据错误
- 403：请求被服务器拒绝
- 404：请求的资源未找到
- 500：服务器错误使其无法为请求提供服务
- 501：客户端发起的请求超出了服务器的能力范围

### 报文格式

HTTP 请求分为三部分：请求方法、地址和协议版本，请求头，请求体：

```
# 方法、地址、协议版本
POST /test HTTP/1.1
# 请求头
Host: ip
Connection: keep-alive
Content-Type: application/json

# 请求体
name=value
```

HTTP 响应分为三部分：协议版本、状态吗，响应头，响应体：
```
HTTP/1.1 200 OK
Content-Type: text/html

<html>
...
```

常见的请求头：
- Host: ip:port             # 目的主机和端口
- Connection: keep-alive    # 保持连接
- Content-Length: 68        # 消息体的长度
- Accept: application/json, text/html, */* # 客户端接收的响应数据类型
- Content-Type: application/json    # 请求数据的类型

常见的响应头：
- Content-Type: application/json    # 服务端接收的类型


### HTTPS

HTTP 协议是基于 TCP 进行传输的，传输的内容是以明文的方式传输的，如果获取了一个 HTTP 报文的消息体就可以直到传输的内容，这种明文方式传输存在很大的风险，如果 HTTP 消息体被劫持，则整个传输过程会面临这几种风险：
- 通信使用明文，通信内容存在窃听风险(eavesdropping)
- 无法证明报文的完整性，存在报文篡改风险(tampering)
- 不验证通信方的身份，存在冒充风险(pretending)

为了防止这些风险的发生，从而诞生了 HTTPS(HyperText Transfer Protocol over Secure Socket Layer) 协议，即在 HTTP 协议置上增加负责处理加密、身份认证 和 完整性保护 的 SSL/TLS 协议。HTTPS 协议中 HTTP 数据报文需要通过 SSL 层进行处理之后才能通过 TCP 协议进行通信。

SSL 协议并不是一个应用层协议，而是介于应用层和传输层之间的一个协议。SSL 使用了对称加密和非对称加密的方式来保证安全，其中非对称加密用于交换对称加密的密钥，而使用对称加密对通信内容进行加密。

**对称加密**指的是加密和解密使用的都是同一个密钥，因此也叫做共享密钥加密。对称加密需要服务器端将密钥发送给客户端，但是在发送过程中如果被截取则加密通信内容失去了意义。对称加密的优点在于加密速度快

**非对称加密**指的是加密和解密使用的是一对公钥和私钥，使用公钥加密的内容只能使用私钥进行解密，同理使用私钥加密的内容只能通过公钥解密。

HTTPS 解决 HTTP 协议的缺陷：
- 防监听：采用对称加密对数据进行加密，采用非对称加密对对称加密的密钥进行加密
- 防伪装：通信双方携带证书，证书通过第三方颁发并且会校验证书的一致性，防止伪造
- 防篡改：采用摘要算法对数据进行校验，防止数据被篡改

HTTS 通信流程：
- 客户端向服务器发起 SSL 通信，报文中包含客户端支持的密钥算法套件，包括支持的 SSL 协议版本、客户端生成的随机数、支持的加密算法、信息摘要算法等
- 服务器从列表中选择一套加密算法、信息摘要算法以及随机数 random_S 和配置的 CA 整数一同返回给客户端，证书中包含了网站地址、加密公钥、证书颁发机构、签名等信息，用于身份验证和密钥交换
- 客户端在收到响应后会对 CA 证书的合法性进行校验，校验包括：
  - 浏览器从内置的受信任的证书机构的 CA 证书与服务器发送的证书对比，如果找不到则不信任
  - 浏览器对 CA 证书中的数据进行签名校验，如果得到的摘要值不相等则不信任
  - todo
- 证书受信任之后，客户端生成随机数 pre-master 并使用证书中的公钥加密发送给服务器，并根据 pre-master 生成加密密钥用于后续通信；同时客户端使用约定好的 hash 算法计算握手信息，然后使用生成的密钥进行加密一起发送给服务器
- 服务器收到客户端发送来的使用公钥加密的对称密钥，使用私钥解密得到对称加密的密钥，再使用这个密钥解密握手信息得到 hash 值，校验 hash 值和计算的 hash 值是否相同，如果一致则认为 SSL 握手成功
- 之后的通信使用对称密钥进行加密


**[Back](../)**
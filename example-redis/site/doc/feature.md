
## Redis Pipelining
Redis 是使用 client-server 模型和 Request/Response 协议的 TCP 服务器，这意味这每次请求都会有以下步骤：
- 客户端向服务器发送查询，并通常以阻塞的方式从 Socket 中读取服务器的响应
- 服务器处理该命令并将响应发送回客户端

客户端和服务器是通过网络来连接的，这种连接可能非常快也可能非常慢，但是无论是何种连接，请求数据包从客户端到服务器然后响应数据包从服务器返回到客户端都是需要时间的，这个时间就成为 RTT(Round Trip Time)。当客户端需要连续执行多个请求时就会严重影响 Redis 的吞吐量，Redis Piplining 解决了这种问题。

Redis Pipelining 通过实现在客户端还没有读取响应数据就处理下一个请求来提升服务器的吞吐量，这样就可以将多个命令发送到服务器而无需等待回复，最后只需一步即可读取全部响应。

当客户端使用 Pipelining 发送命令的时候，服务器将强制使用内存对请求进行排队，因此如果需要使用 Pipelining 发送大量的命令，需要设置一个比较合理的批次。

Pipelining 技术不仅解决了 RTT 耗时，而且也大大提高了 Redis 服务器每秒可执行的操作量。这是因为，在不使用 Pipelining 的情况下，Socket I/O 操作是非常昂贵的，因为涉及到 read() 和 write() 系统调用，也就意味着用户进程和内核进程的切换，这个切换在速度上代价非常大。使用 Pipelining 操作，使用单个 read() 系统调用执行多个请求命令，并使用单个 write() 系统调用返回多个响应。因此每秒执行的总查询数会随着 Pipelining 的长度线性增加并最终达到不使用 Pipelining 的 10倍。

## Redis 事务

## Redis 分布式锁
使用分布式锁需要的最低保证需要三个特性：
- **互斥性**：锁是互斥的，即在任何给定的时刻只能有一个 client 可以持有锁
- **活性**：没有死锁，也就是即使锁定资源的 client 崩溃或者被分区，最终也是可以获取锁的
- **容错性**：只要大多数 redis 节点都启动了，client 就可以获取和释放锁

### Reids 单节点分布式锁实现
使用 Redis 单节点实现分布式锁的方式：
> 在 Redis 中创建一个 key 并设定该 key 的过期时间，当 client 端释放资源时将该 key 删除。由于有设置过期时间，即使 client 没有删除该 key 过期时间到达时也会自动删除该 key。

这种利用 Redis 实现分布式锁的方式比较简单，但是存在单点问题(当 master 崩溃则整个分布式锁不可用)。如果增加 slave 节点使得 master 节点在崩溃后 slave 替代 master 看起来可以避免单点问题，但是由于 Redis 的复制是异步的，所以有可能 master 在崩溃时并没有将所有的数据复制到 slave 上，此时会出现多个 client 获取到锁：
- client A 在 master 上获取到锁
- master 在把 key 复制到 slave 前崩溃
- slave 被选举为新的 master
- client B 可以获取到和 A 一样的锁

使用 Redis 单节点实现分布式锁：
- 使用 ```SETNX resource_name random_value PX timeout``` 命令只有当 key 不存在时才会设置成功且对该 key 设置了过期时间
- 删除锁之前使用 get 命令查看 key 的值是否是当前 client 设置的值，如果是则删除否则不删除。由于需要 get 后比较这种非原子操作，因此可能会出现问题，Redis 提供了 Lua 脚本解决这种问题 ```if redis.call("get".KEYS[1] == ARGV[1] then return redis.call("del",KEYS[1])) else return 0 end```
### RedLock 算法
分布式环境下的锁需要 N 个 Reids 的 master 节点，每个节点独立。当需要获取锁的时候 client 需要以下操作：
- 获取当前系统时间
- client 尝试按顺序在 N 个 master 实例上都获取单个实例的锁，每个实例的锁的 key 相同但是值是随机的。在为每个实例设置锁时，client 使用一个超时，该超时与锁自动释放的总时间相比很小，这样可以防止 client 在尝试与已经关闭的 redis 节点交互时长时间处于阻塞状态
- client 通过从当前时间减去之前获取的系统时间戳来计算获取锁所用的时间，当且仅当 client 能够在大多数实例中获取到锁并且获取到锁所花费的总时间小于锁有效时间时，才认为已经获取锁
- 如果 client 获取到锁，则该锁的有效时间为锁的初始有效时间减去计算出的获取锁的时间
- 如果 client 由于某种原因无法获取锁，它将尝试解锁所有实例

RedLock 注意点：
- 假设 client 可以获取大部分实例的锁，每个实例都会有相同的过期时间(TTL)，但是由于不同的实例获取锁的时间不同所以过期的时间点也会不同。如果第一个实例的 key 在 T1 设置，最后一个实例的 key 在 T2 设置，则此 client 有效获取锁的最小时间为 TTL - (T2 -T1)
- 只有 client 获取一半以上的实例的锁时，才有可能成功获取锁
- 如果 client 获取大部分实例的锁的时间接近或者大于锁的有效时间(key 的过期时间)，则会认为锁无效并且需要释放已经获取的实例锁
- 释放锁时需要释放所有实例的锁，即使是认为没有获取该实例的锁


**[Back](../)**
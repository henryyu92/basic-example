## Redis 分布式锁
使用分布式锁需要的最低保证需要三个特性：
- **互斥性**：锁是互斥的，即在任何给定的时刻只能有一个 client 可以持有锁
- **活性**：没有死锁，也就是即使锁定资源的 client 崩溃或者被分区，最终也是可以获取锁的
- **容错性**：只要大多数 redis 节点都启动了，client 就可以获取和释放锁

### Reids 单节点分布式锁实现
使用 Redis 单节点实现分布式锁的方式：
> 在 Redis 中创建一个 key 并设定该 key 的过期时间，当 client 端释放资源时将该 key 删除。由于有设置过期时间，即使 client 没有删除该 key 过期时间到达时也会自动删除该 key。

这种利用 Redis 实现分布式锁的方式比较简单，但是存在单点问题(当 master 崩溃则整个分布式锁不可用)。如果增加 slave 节点使得 master 节点在崩溃后 slave 替代 master 看起来可以避免单点问题，但是由于 Redis 的复制是异步的，所以有可能 master 在崩溃时并没有将所有的数据复制到 slave 上，此时会出现多个 client 获取到锁：
- client A 在 master 上获取到锁
- master 在把 key 复制到 slave 前崩溃
- slave 被选举为新的 master
- client B 可以获取到和 A 一样的锁

使用 Redis 单节点实现分布式锁：
- 使用 ```SETNX resource_name random_value PX timeout``` 命令只有当 key 不存在时才会设置成功且对该 key 设置了过期时间
- 为了避免之前过期的锁持有者再次删除锁，在删除锁之前使用 get 命令查看 key 的值是否是当前 client 设置的值，如果是则删除否则不删除。由于需要 get 后比较这种非原子操作，因此可能会出现问题，Redis 提供了 Lua 脚本解决这种问题 ```if redis.call("get".KEYS[1] == ARGV[1] then return redis.call("del",KEYS[1])) else return 0 end```
### RedLock 算法
分布式环境下的锁需要 N 个 Reids 的 master 节点，每个节点独立。当需要获取锁的时候 client 需要以下操作：
- 获取当前系统时间
- client 尝试按顺序在 N 个 master 实例上都获取单个实例的锁，每个实例的锁的 key 相同但是值是随机的。在为每个实例设置锁时，client 使用一个超时，该超时与锁自动释放的总时间相比很小，这样可以防止 client 在尝试与已经关闭的 redis 节点交互时长时间处于阻塞状态
- client 通过从当前时间减去之前获取的系统时间戳来计算获取锁所用的时间，当且仅当 client 能够在大多数实例中获取到锁并且获取到锁所花费的总时间小于锁有效时间时，才认为已经获取锁
- 如果 client 获取到锁，则该锁的有效时间为锁的初始有效时间减去计算出的获取锁的时间
- 如果 client 由于某种原因无法获取锁，它将尝试解锁所有实例

RedLock 注意点：
- 假设 client 可以获取大部分实例的锁，每个实例都会有相同的过期时间(TTL)，但是由于不同的实例获取锁的时间不同所以过期的时间点也会不同。如果第一个实例的 key 在 T1 设置，最后一个实例的 key 在 T2 设置，则此 client 有效获取锁的最小时间为 TTL - (T2 -T1)
- 只有 client 获取一半以上的实例的锁时，才有可能成功获取锁
- 如果 client 获取大部分实例的锁的时间接近或者大于锁的有效时间(key 的过期时间)，则会认为锁无效并且需要释放已经获取的实例锁
- 释放锁时需要释放所有实例的锁，即使是认为没有获取该实例的锁
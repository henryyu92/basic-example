## 数据类型

### 对象
Redis 基于基础的数据结构创建了一个对象系统，包括字符串对象、列表对象、哈希对象、集合对象和有序集合对象。Redis 在执行命令之前会先判断对象是否可以执行给定的命令，此外 Redis 的对象系统实现了基于引用计数技术的内存回收机制，通过引用计数实现了对象共享机制来节约内存。
#### 对象类型
Redis 使用对象表示数据库中的键和值，键总是一个字符串对象，而值可以是字符串对象、列表对象、哈希对象、集合对象或有序集合对象中的一种。每次在创建一个键值对时，至少会创建一个键对象和一个值对象。

Reids 中每个对象都由一个 redisObject 结构表示：
```c
typedef struct redisObject{
    unsigned type:4;
    unsigned encoding:4;
    void *ptr;
}robj;
```
- type 属性记录了对象的类型，Redis 有 5 中对象类型，使用 type 命令可以得到键对应的值的对象类型
- encoding 属性记录了对象所使用的编码，即指定了对象的底层数据结构的实现。使用 object encoding 命令查看键对应的值对象的编码
- ptr 指针指向对象的底层实现数据结构，具体数据结构由 encoding 属性决定

#### 字符串对象
字符串对象的编码可以是 int, raw 和 embstr：
- 如果字符串对象保存的是整数并且这个整数值可以用 long 类型来表示，则 encoding 为 int 且 ptr 保存了整数值
- 如果字符串对象保存的是字符串值并且这个字符串值的长度大于 32 字节，那么字符串对象使用简单动态字符串(SDS)保存字符串值并将 encoding 设置为 raw
- 如果字符串对象保存的是字符串值并且这个字符串值的长度小于等于 32 字节，那么字符串对象将使用 embstr 编码方式保存字符串值

embstr 编码专门用于保存短字符串，这种编码和 raw 一样使用 redisObject 和 sdshdr 结构表示字符串，不同的是 raw 需要两次内存分配创建 redisObject 和 sdshdr 结构，而 embstr 调用一次内存分配来分配一块连续的空间包含 redisObject 和 sdshdr 两个结构。

long 和 doule 类型表示的浮点数在 Redis 中也是作为字符串值保存的，在保存和使用的过程中需要进行编码转换。同时在对 int 和 embstr 编码的字符串对象进行一些操作时，字符串对象编码会转换为 raw。
#### 列表对象
列表对象的编码可以是 ziplist 和 linkedlist：
- ziplist 编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点(entry)保存了一个列表元素
- linkedlist 编码的列表对象使用双端链表作为底层实现，每个双端链表节点(node)都保存了一个字符串对象，每个字符串对象都保存了一个列表元素

列表对象使用 ziplist 编码时需要同时满足条件：
- 列表对象保存的所有字符串元素的长度都小于 64 字节
- 列表对象保存的元素数量小于 512 个

当使用 ziplist 编码的列表对象不能同时满足上述两个条件时， ziplist 编码的列表对象就会转移到双端链表，编码从 ziplist 变为 linkedlist

新版本的列表对象编码使用的是 quicklist：
#### 哈希对象
哈希对象的编码可以是 ziplist 和 hashtable：
- 使用 ziplist 编码的哈希对象，当有新的键值对加入哈希对象时，先将保存了键的结点推入到压缩列表表尾，然后将保存了值的结点推入到压缩列表表尾
- 使用 hashtable 编码的哈希对象，哈希对象中的每个键值对都使用一个字典键值对来保存：字典的每个键是一个字符串对象，保存键值对的键；字典的每个值都是一个字符串对象，保存键值对的值

哈希对象使用 ziplist 编码需要同时满足条件：
- 哈希对象保存的所有键值对的键和值得字符串长度都小于 64 字节
- 哈希对象保存的键值对数量小于 512 个，可以通过配置 ```hash-max-ziplist-entries``` 修改

当使用 ziplist 编码的哈希对象不满足其中任意条件时就会执行编码转换会，保存在压缩列表中的键值对会保存到字典中，对象的编码有 ziplist 转变为 hashtable。
#### 集合对象
集合对象的编码可以是 intset 和 hashtable：
- intset 编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都保存在整数集合里面
- hashtable 编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象都包含了一个集合元素，字典的值设置为 null

集合对象使用 intset 编码需要同时满足条件：
- 集合对象保存的所有元素都是整数值
- 集合对象保存的元素数量不超过 512 个，可以修改配置 ```set-max-intset-entries``` 改变

对于使用 intset 编码的集合来说，当条件不满足时就会执行对象的编码转换操作，原本保存在整数集合中的所有元素都会被转移并保存到字典里面并且对象的编码也会从 intset 变为 hashtable。
#### 有序集合对象
有序集合对象的编码可以是 ziplist 和 skiplist：
- ziplist 编码的有序集合对象底层使用压缩列表实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员(member)，第二个元素保存元素的分值(score)。压缩列表内的集合元素按照分值从小到大排序，分值较小的元素放置在靠近表头的方向，分值较大的元素放置在靠近表尾的方向。
- skiplist 编码的有序集合对象使用 zset 结构作为底层实现，一个 zset 结构同时包含一个字典和一个跳跃表。跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素，跳跃表节点的 object 属性保存了元素的成员，而 score 属性则保存了元素的分值；除了跳跃表之外，zset 中的 dict 字典为有序集合创建了一个从成员到分值的映射，每个键值对都保存了一个集合元素，字典的键保存了元素成员，值保存了元素的分值。跳跃表和字典通过指针共享相同元素的值和分值，因此不会占用额外的内存。

有序集合对象使用 ziplist 编码需要同时满足条件：
- 有序集合保存的元素数量小于 128 个，可以通过配置 ```zset-max-ziplist-entries``` 修改
- 有序集合保存的所有元素成员的长度都小于 64 字节，可以通过配置 ```zset-max-ziplist-value``` 修改

对于使用 ziplist 编码的有序集合对象来说，当条件不满足时就会执行对象的编码转换操作，保存在压缩列表中的元素都会转移到 zset 里面，对象的编码也会从 ziplist 变为 skiplist。

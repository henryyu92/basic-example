## 动态规划



动态规划算法通常按照 4 个步骤来设计：
- 刻画一个最优解的结构特征
- 递归的定义最优解的值
- 计算最优解的值，通常采用自底向上的方法
- 利用计算出的信息构造一个最优解


### 子问题图
当思考一个动态规划问题时，需要清楚子问题及子问题之间的依赖关系，子问题图准确地表达了这些信息。子问题图是一个有向图，每个顶点唯一地对应一个子问题，若求子问题 x 地最优解时需要直接使用到子问题 y 地最优解，那么在子问题图中就会有一条从子问题 x 的顶点到子问题 y 的顶点的有向边。

适合应用动态规划方法求解的最优化问题应具备两个要素：最优子结构和子问题重叠。
### 最优子结构
如果一个问题的最优解由相关子问题的最优解组合而成，则此类问题具有最优子结构性质。

发掘最优子结构性质会遵循一些通用模式：
- 证明问题最优解的第一个组成部分是做出一个选择，做出这次选择会产生一个或多个待解的子问题
- 对于一个给定的问题，在其可能的第一步选择中，假定已经直到那种选择才会得到最优解，而不必关心如何得到选择
- 证明每个子问题的解就是问题的最优解
### 重叠子问题
适合用动态规划方法求解的最优化问题应该是子问题空间必须足够小，即问题的递归算法会反复地求解相同地子问题，而不是一直生成新地子问题。动态规划算法通常利用重叠子问题地性质，对每个子问题求解一次，将解存入一个表中，当再次需要这个子问题时直接查表，每次查表代价为常量时间。


### 钢条切割问题
问题描述：给定一段长度为 n 的钢条和一个价格表 p(i) 给出切割方案使得收益 r(n) 最大。

**分治法**

在距离钢条左端 i(i = 1,2,...n-1) 处都可以选择切割或者不切割，所以对于所有的切割方案有：首先将钢条且分为两段 i 和 n-i，然后再将 n-i 长度的钢条进行切分来获取最大收益，最后在所有的收益中选择最大收益作为钢条切割的最后方案。
```go
func cut_rod(p []int, n int) int {
    if n == 0{
        return 0
    }
    q := 0
    for i:=1; i <= n ; i ++{
        v := p[i] + cut_rod(p, n - i)
        if v > q{
            q = v
        }
    }
    return q
}
```
使用分治分割的子问题之间有公共的子子问题，此时会重复运算相同的子子问题从而浪费性能。从时间复杂度分析，递归方式的时间 T(n) = 1 + T(1) ＋　T(2) + ... + T(n-1)，可得 T(n) = 2^n，即递归的时间复杂度是指数级 O(2^N)。

递归实现考察了所有 2^(n-1) 种可能的切割方案，递归调用树种共有 2^(n-1) 个叶节点，每个叶节点对应一种可能的钢条切割方案。

**动态规划**

朴素递归反复求解相同的子问题，动态规划方法仔细安排求解顺序，对每个子问题只求解一次并将结果保存下来，如果随后再次需要此问题的解，只需查找保存的结果而不必重新计算。动态规划方法是付出额外的内存空间来节省计算时间，可能将一个指数时间转化为一个多项式时间的解。

动态规划有两种等价实现方法：
- 带备忘的自顶向下法(top-down with memoization)：此方法按自然的递归形式编写过程，但过程会保存每个子问题的解(通常保存在一个数组或散列表中)，当需要一个子问题的解时首先检查是否已经保存过此解，如果是则直接返回保存的值从而节省计算时间，否则按照通常方式计算这个子问题。
- 自底向上法(bottom-up-method)：此种方法一般需要恰当定义子问题“规模”的概念，使得任何子问题的求解都只依赖于更小的子问题求解。因此可以将子问题按照规模排序，按由小到大的顺序进行求解，当求解某子问题时，它所依赖的那些更小的子问题都已经求解完毕并保存。

自顶向下实现：
```go
func memoized_cut_rod(p []int, n int){
    var arr [n]int
    // 初始化数组
    for i := 0; i < n; i++{
        arr[i] = -1
    }
    process(p, n, r)

}
// 长度为 i 的最大价值
func process(p []int, i int, r []int)int {
    // 已存在不需要再次计算
    if r[i] >= 0{
        return r[i];
    }
    if i == 0{
        return 0;
    }
    var q int
    for x:=0; x < n; x++{
        v := p[i] + cut_rod(p, n - i)
        if v > q{
            q = v
        }
    }
    return q
}
```
自底向上实现：
```go
func cut_rod(p []int, n int){
    var r [n]int
    // 长度为 0 的钢条收益为 0
    r[0] = 0;
    // 依次计算长度为 1~n 的钢条收益
    for j:= 1; j <= n; j++{
        var q int
        // 长度为 j 的切割方案
        for i = 1; i <= j; i++{
            v := p[i] + r[j-i]
            if v > q{
                q = v
            }
        }
        r[i] = q
    }
    return r[n]
}
```
#### 最长公共子序列问题(LCS)

问题描述：给定序列 X=[x1, x2, x3, ..., xm] 和序列 Y=[y1, y2, y3, ..., yn], 存在序列 Z = [z1, z2, ..., zk] 使得 Z 是 X 子序列同时也是 Y 的子序列。

定义序列的前缀：给定一个序列 X=[x1, x2, x3, ..., xm]，对于 i=0, 1, 2, ..., m，定义 X 的第 i 前缀为 Xi=[x1, x2, ..., xi]

LCS 问题的最优子结构：
- 如果 xm = yn，则 zk=xm=yn 且 Zk-1 是 Xm-1 和 Yn-1 的一个 LCS
- 如果 xm != yn 且 zk != xm，则 Z 是 Xm-1 和 Y 的一个 LCS
- 如果 xm != yn 且 zk != yn，则 Z 是 X 和 Yn-1 的一个 LCS

由最优子结构可得 X 和 Y 的 LCS 是由两部分组成：如果 xm=yn 则求解 Xm-1 和 Yn-1 的 LCS 然后将 xm=yn 追加到 LCS 的末尾，如果 xm!=yn 则需要计算 Xm-1 和 Y 的 LCS 以及 X 和 Yn-1 的 LCS 并取较大的 LCS。使用 c[i, j] 表示 Xi 和 Yj 的 LCS 长度，如果 i = 0 或者 j = 0 则 LCS 为 0，可以得到公式：
```
          --- 0                 i=0 或者 j=0
          |
c[i, j] = |-- c[i-1,j-1]+1      xi=xj
          |
          --- max(c[i, j-1], c[i-1, j])   xi != xj
```
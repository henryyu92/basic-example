### 计数排序
计数排序假设 N 个输入元素中的每一个都是在 0 到 k 区间内的一个整数，其中 k 为某个整数，当 k = O(N) 时，排序的运行时间为 O(N)

计数排序的基本思想是：对每一个输入元素 x，统计该元素出现的个数，然后将这些元素按照出现的个数依次写回原数组

- 时间复杂度：O(k+N)
- 空间复杂度：O(k+N)
- 稳定性：稳定，具有相同值得元素在输出数组中的相对次序与在输入数组中的相对次序相同

算法实现：
```go
func countingSort(arr int[]){
    // 确定集合的数据范围
    max := 0;
    for i := 0; i < len(arr); i++{
        max = max > arr[i] ? max : arr[i]
    }
    bucket := [max + 1]int
    // 遍历集合统计每个元素的个数
    for j := 0; j < len(arr); j++{
        bucket[arr[j]]++;
    }
    // 将每个元素在原数组中拷贝出现的次数
    i := 0
    for j := 0; j < len(bucket); j++{
        for ;bucket[j] < 0; {
            arr[i++] = j
            bucket[j]--
        }
    }
}
```
### 基数排序
基数排序先按最低有效位进行排序，然后将已排序好的数据按照次低有效位进行排序，重复这个排序过程直到对所有 d 位数字都进行了排序。

复杂度分析：
> 给定 n 个 d 位数，其中每一个数位有 k 个可能的取值，则可以在 O(d(n+k)) 时间内将这些数排好序

```go
func radixSort(arr []int){

}
```
### 桶排序
桶排序假设输入数据服从均匀分布，平均情况下的时间代价为 O(N)。与计数排序假设数据都属于一个小区间内的整数不同，桶排序假设输入是由一个随机过程产生，该过程将元素均匀、独立地分布在 [0, 1) 区间上。

桶排序将 [0, 1) 区间划分为 N 个相同大小的子区间(桶)，然后将 N 个输入元素分别放到各个桶中，因为输入数据是均匀、独立的分布在 [0, 1) 上，所以不会出现很多数据落在同一个桶中的情况，只需要先独立的对每个桶中的元素进行排序，然后遍历每个桶按照次序把各个桶中的元素列出来即可。

算法实现：
```go
func bucketSort(arr []int){
    help := make([]int, len(arr))
}
```

> 快速排序是将集合拆分为两个值域，这里称为两个桶，再分别对两个桶进行排序，最终完成排序。桶排序则是将集合拆分为多个桶，对每个桶进行排序，则完成排序过程。两者不同之处在于，快排是在集合本身上进行排序，属于原地排序方式，且对每个桶的排序方式也是快排。桶排序则是提供了额外的操作空间，在额外空间上对桶进行排序，避免了构成桶过程的元素比较和交换操作，同时可以自主选择恰当的排序算法对桶进行排序。

> 当然桶排序更是对计数排序的改进，计数排序申请的额外空间跨度从最小元素值到最大元素值，若待排序集合中元素不是依次递增的，则必然有空间浪费情况。桶排序则是弱化了这种浪费情况，将最小值到最大值之间的每一个位置申请空间，更新为最小值到最大值之间每一个固定区域申请空间，尽量减少了元素值大小不连续情况下的空间浪费情况。

桶排序是将待排序集合中处于同一个值域的元素存入同一个桶中，也就是根据元素值特性将集合拆分为多个区域，则拆分后形成的多个桶从值域上看是处于有序状态的。对每个桶中元素进行排序，则所有桶中元素构成的集合是已排序的。

桶排序过程中存在两个关键环节：
- 元素值域的划分，也就是元素到桶的映射规则。映射规则需要根据待排序集合的元素分布特性进行选择，若规则设计的过于模糊、宽泛，则可能导致待排序集合中所有元素全部映射到一个桶上，使得桶排序向比较性质排序算法演变；若映射规则设计的归于具体、严苛则可能导致待排序集合中每一个元素映射到一个桶上，使得桶排序向计数排序算法演变
- 排序算法的选择，从待排序集合中元素映射到各个桶上的过程，并不存在元素的比较和交换操作，在对各个桶中元素进行排序时，可以自主选择合适的排序算法，桶排序算法的复杂度和稳定性都根据选择的排序算法不同而不同

算法过程：
- 根据待排序集合中最大元素和最小元素的差值范围和映射规则，确定桶的个数
- 遍历待排序集合，将每一个元素移动到对应的桶中
- 对每一个桶中元素进行排序，并移动到已排序集合中

```python
def bucketSort(arr):
    maximum, minimum = max(arr), min(arr)
    bucketArr = [[] for i in range(maximum // 10 - minimum // 10 + 1)]  # set the map rule and apply for space
    for i in arr:  # map every element in array to the corresponding bucket
        index = i // 10 - minimum // 10
        bucketArr[index].append(i)
    arr.clear()
    for i in bucketArr:
        heapSort(i)   # sort the elements in every bucket
        arr.extend(i)  # move the sorted elements in bucket to array
```
第一个循环作用为将待排序集合中元素移动到对应的桶中，复杂度为 O(N)；第二个循环的作用为对每个桶中元素进行排序，并移动回初始集合中，若桶个数为 M，平均每个桶中元素个数为 N/M，则复杂度为 ```O(M*N/Mlog(N/M) + N)=O(N+N(logN - log M))```。当 M==N 时，即桶排序向计数排序方式演化，则堆排序不发挥作用，复杂度为 O(N)，只需要将元素移动回初始集合即可。当 M==1 时，即桶排序向比较性质排序算法演化，对集合进行堆排序，并将元素移动回初始集合，复杂度为 O(N+NlogN)。

算法分析：
> 桶排序的时间复杂度为 O(N+N(lgN-lgM))，其中 M 表示桶的个数。由于需要使用额外的空间来保存元素，所以空间复杂度为 O(N+M)。算法的稳定性取决于对桶中元素排序时选择的排序算法。
